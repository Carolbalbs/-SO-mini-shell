{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Documenta\u00e7\u00e3o do Projeto Mini Shell Introdu\u00e7\u00e3o Este projeto consiste na implementa\u00e7\u00e3o de um shell b\u00e1sico em linguagem C, como parte da disciplina de Sistemas Operacionais ministrada pela professora Larissa Barbosa Le\u00f4ncio Pinheiro. O objetivo principal \u00e9 compreender e aplicar conceitos importantes de como um interpretador de comandos funciona por tr\u00e1s dos panos \u2014 similar ao que acontece em terminais como o bash ou o zsh. A proposta foi desenvolver, do zero, um programa capaz de interpretar comandos digitados pelo usu\u00e1rio, executar programas externos, e oferecer suporte a comandos internos como exit, echo e env. Tudo isso utilizando apenas recursos da biblioteca padr\u00e3o e chamadas POSIX \u2014 sem usar bibliotecas prontas como readline ou sistemas de parsing autom\u00e1ticos. Al\u00e9m de aplicar os conceitos te\u00f3ricos, o projeto tamb\u00e9m visa desenvolver habilidades pr\u00e1ticas, como: Manipula\u00e7\u00e3o de processos com fork, execvp, wait; Gerenciamento de mem\u00f3ria din\u00e2mica com malloc e realloc; Leitura de entrada em baixo n\u00edvel com read(); Tratamento de erros e uso de c\u00f3digos de retorno; E principalmente, a organiza\u00e7\u00e3o modular do c\u00f3digo, separando funcionalidades em arquivos e fun\u00e7\u00f5es espec\u00edficas. Por fim, a experi\u00eancia do usu\u00e1rio tamb\u00e9m foi considerada, com elementos como prompt colorido, mensagens amig\u00e1veis e uma pequena anima\u00e7\u00e3o de sa\u00edda para tornar o uso do shell mais interativo e did\u00e1tico.","title":"Introdu\u00e7\u00e3o"},{"location":"#documentacao-do-projeto-mini-shell","text":"","title":"Documenta\u00e7\u00e3o do Projeto Mini Shell"},{"location":"#introducao","text":"Este projeto consiste na implementa\u00e7\u00e3o de um shell b\u00e1sico em linguagem C, como parte da disciplina de Sistemas Operacionais ministrada pela professora Larissa Barbosa Le\u00f4ncio Pinheiro. O objetivo principal \u00e9 compreender e aplicar conceitos importantes de como um interpretador de comandos funciona por tr\u00e1s dos panos \u2014 similar ao que acontece em terminais como o bash ou o zsh. A proposta foi desenvolver, do zero, um programa capaz de interpretar comandos digitados pelo usu\u00e1rio, executar programas externos, e oferecer suporte a comandos internos como exit, echo e env. Tudo isso utilizando apenas recursos da biblioteca padr\u00e3o e chamadas POSIX \u2014 sem usar bibliotecas prontas como readline ou sistemas de parsing autom\u00e1ticos. Al\u00e9m de aplicar os conceitos te\u00f3ricos, o projeto tamb\u00e9m visa desenvolver habilidades pr\u00e1ticas, como: Manipula\u00e7\u00e3o de processos com fork, execvp, wait; Gerenciamento de mem\u00f3ria din\u00e2mica com malloc e realloc; Leitura de entrada em baixo n\u00edvel com read(); Tratamento de erros e uso de c\u00f3digos de retorno; E principalmente, a organiza\u00e7\u00e3o modular do c\u00f3digo, separando funcionalidades em arquivos e fun\u00e7\u00f5es espec\u00edficas. Por fim, a experi\u00eancia do usu\u00e1rio tamb\u00e9m foi considerada, com elementos como prompt colorido, mensagens amig\u00e1veis e uma pequena anima\u00e7\u00e3o de sa\u00edda para tornar o uso do shell mais interativo e did\u00e1tico.","title":"Introdu\u00e7\u00e3o"},{"location":"#_1","text":"","title":""},{"location":"builtin/","text":"Implementa\u00e7\u00e3o de Comandos Built-in builtin.c O arquivo builtin.c \u00e9 respons\u00e1vel por implementar os comandos built-in do shell. Comandos built-in s\u00e3o fun\u00e7\u00f5es que s\u00e3o executadas diretamente pelo shell, em vez de serem programas externos. Isso os torna mais r\u00e1pidos e eficientes, pois n\u00e3o exigem a cria\u00e7\u00e3o de um novo processo. Atualmente, este arquivo cont\u00e9m as implementa\u00e7\u00f5es para os comandos exit e env . int index_exit(char **args) Prop\u00f3sito : Implementa o comando exit , que encerra a execu\u00e7\u00e3o do shell. Argumentos : char **args - um array de strings contendo os argumentos passados para o comando exit . Embora o prot\u00f3tipo aceite argumentos, a implementa\u00e7\u00e3o atual n\u00e3o os utiliza ( (void)args; ). Funcionalidade : Antes de sair, a fun\u00e7\u00e3o chama spinnerLoading() , que exibe uma anima\u00e7\u00e3o de desligamento, proporcionando uma experi\u00eancia de usu\u00e1rio mais agrad\u00e1vel. Ap\u00f3s a anima\u00e7\u00e3o, o shell \u00e9 encerrado com exit(EXIT_SUCCESS) , indicando uma sa\u00edda bem-sucedida. Retorno : N\u00e3o retorna, pois a fun\u00e7\u00e3o exit() encerra o processo. int index_env(char **args) Prop\u00f3sito : Implementa o comando env , que exibe as vari\u00e1veis de ambiente do processo atual. Argumentos : char **args - um array de strings contendo os argumentos passados para o comando env . A implementa\u00e7\u00e3o atual n\u00e3o os utiliza ( (void)args; ). Funcionalidade : A fun\u00e7\u00e3o acessa a vari\u00e1vel global environ (declarada como extern char **environ; ), que \u00e9 um ponteiro para um array de strings, onde cada string representa uma vari\u00e1vel de ambiente no formato NOME=VALOR . A fun\u00e7\u00e3o itera sobre este array e imprime cada vari\u00e1vel de ambiente em uma nova linha usando a macro p (que envolve printf ). Comportamento em Erro : Se environ for nulo (o que \u00e9 improv\u00e1vel em um ambiente POSIX t\u00edpico, mas \u00e9 uma verifica\u00e7\u00e3o de seguran\u00e7a), a fun\u00e7\u00e3o retorna 1 , indicando um erro. Caso contr\u00e1rio, retorna 0 para sucesso. Retorno : Retorna 0 em caso de sucesso e 1 em caso de falha. int cell_echo(char **args) Prop\u00f3sito : Implementa o comando echo , que imprime os argumentos fornecidos na sa\u00edda padr\u00e3o. Suporta a op\u00e7\u00e3o -n para suprimir a nova linha final. Argumentos : char **args - um array de strings contendo os argumentos para o comando echo . Funcionalidade : A fun\u00e7\u00e3o verifica se o segundo argumento ( args[1] ) \u00e9 \"-n\" . Se for, a flag newline \u00e9 definida como false e o \u00edndice de in\u00edcio para a impress\u00e3o dos argumentos \u00e9 ajustado para 2 (pulando echo e -n ). Caso contr\u00e1rio, a impress\u00e3o come\u00e7a do \u00edndice 1 . A fun\u00e7\u00e3o ent\u00e3o itera sobre os argumentos restantes, imprimindo cada um. Um espa\u00e7o \u00e9 adicionado entre os argumentos. Finalmente, se a flag newline for true , uma nova linha \u00e9 impressa. Comportamento em Erro : Se args for nulo ou args[0] for nulo, a fun\u00e7\u00e3o retorna 1 , indicando um erro. Retorno : Retorna 0 em caso de sucesso e 1 em caso de falha. Este arquivo centraliza a l\u00f3gica para comandos que s\u00e3o parte integrante do shell, garantindo que eles sejam executados de forma eficiente e com o comportamento esperado.","title":"Implementa\u00e7\u00e3o de Comandos Built-in"},{"location":"builtin/#implementacao-de-comandos-built-in","text":"","title":"Implementa\u00e7\u00e3o de Comandos Built-in"},{"location":"builtin/#builtinc","text":"O arquivo builtin.c \u00e9 respons\u00e1vel por implementar os comandos built-in do shell. Comandos built-in s\u00e3o fun\u00e7\u00f5es que s\u00e3o executadas diretamente pelo shell, em vez de serem programas externos. Isso os torna mais r\u00e1pidos e eficientes, pois n\u00e3o exigem a cria\u00e7\u00e3o de um novo processo. Atualmente, este arquivo cont\u00e9m as implementa\u00e7\u00f5es para os comandos exit e env .","title":"builtin.c"},{"location":"builtin/#int-index_exitchar-args","text":"Prop\u00f3sito : Implementa o comando exit , que encerra a execu\u00e7\u00e3o do shell. Argumentos : char **args - um array de strings contendo os argumentos passados para o comando exit . Embora o prot\u00f3tipo aceite argumentos, a implementa\u00e7\u00e3o atual n\u00e3o os utiliza ( (void)args; ). Funcionalidade : Antes de sair, a fun\u00e7\u00e3o chama spinnerLoading() , que exibe uma anima\u00e7\u00e3o de desligamento, proporcionando uma experi\u00eancia de usu\u00e1rio mais agrad\u00e1vel. Ap\u00f3s a anima\u00e7\u00e3o, o shell \u00e9 encerrado com exit(EXIT_SUCCESS) , indicando uma sa\u00edda bem-sucedida. Retorno : N\u00e3o retorna, pois a fun\u00e7\u00e3o exit() encerra o processo.","title":"int index_exit(char **args)"},{"location":"builtin/#int-index_envchar-args","text":"Prop\u00f3sito : Implementa o comando env , que exibe as vari\u00e1veis de ambiente do processo atual. Argumentos : char **args - um array de strings contendo os argumentos passados para o comando env . A implementa\u00e7\u00e3o atual n\u00e3o os utiliza ( (void)args; ). Funcionalidade : A fun\u00e7\u00e3o acessa a vari\u00e1vel global environ (declarada como extern char **environ; ), que \u00e9 um ponteiro para um array de strings, onde cada string representa uma vari\u00e1vel de ambiente no formato NOME=VALOR . A fun\u00e7\u00e3o itera sobre este array e imprime cada vari\u00e1vel de ambiente em uma nova linha usando a macro p (que envolve printf ). Comportamento em Erro : Se environ for nulo (o que \u00e9 improv\u00e1vel em um ambiente POSIX t\u00edpico, mas \u00e9 uma verifica\u00e7\u00e3o de seguran\u00e7a), a fun\u00e7\u00e3o retorna 1 , indicando um erro. Caso contr\u00e1rio, retorna 0 para sucesso. Retorno : Retorna 0 em caso de sucesso e 1 em caso de falha.","title":"int index_env(char **args)"},{"location":"builtin/#int-cell_echochar-args","text":"Prop\u00f3sito : Implementa o comando echo , que imprime os argumentos fornecidos na sa\u00edda padr\u00e3o. Suporta a op\u00e7\u00e3o -n para suprimir a nova linha final. Argumentos : char **args - um array de strings contendo os argumentos para o comando echo . Funcionalidade : A fun\u00e7\u00e3o verifica se o segundo argumento ( args[1] ) \u00e9 \"-n\" . Se for, a flag newline \u00e9 definida como false e o \u00edndice de in\u00edcio para a impress\u00e3o dos argumentos \u00e9 ajustado para 2 (pulando echo e -n ). Caso contr\u00e1rio, a impress\u00e3o come\u00e7a do \u00edndice 1 . A fun\u00e7\u00e3o ent\u00e3o itera sobre os argumentos restantes, imprimindo cada um. Um espa\u00e7o \u00e9 adicionado entre os argumentos. Finalmente, se a flag newline for true , uma nova linha \u00e9 impressa. Comportamento em Erro : Se args for nulo ou args[0] for nulo, a fun\u00e7\u00e3o retorna 1 , indicando um erro. Retorno : Retorna 0 em caso de sucesso e 1 em caso de falha. Este arquivo centraliza a l\u00f3gica para comandos que s\u00e3o parte integrante do shell, garantindo que eles sejam executados de forma eficiente e com o comportamento esperado.","title":"int cell_echo(char **args)"},{"location":"casos%20de%20uso/","text":"Casos de Uso Detalhados para o Mini-Shell Exemplos de Comandos Testados e Suas Sa\u00eddas O mini-shell suporta a execu\u00e7\u00e3o de comandos built-in e externos, al\u00e9m de redirecionamento de I/O e pipes. Comandos Built-in exit : \ud83d\udc1a/home/ubuntu\ud83d\udc1a$> exit Shutting down... [===========\ud83d\udca5] \u2705 EXIT \u2705 Encerra o mini-shell com uma anima\u00e7\u00e3o de desligamento. env : \ud83d\udc1a/home/ubuntu\ud83d\udc1a$> env TERM=xterm PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin LANG=C.UTF-8 ... (outras vari\u00e1veis de ambiente) Exibe as vari\u00e1veis de ambiente do processo atual. echo <texto> : \ud83d\udc1a/home/ubuntu\ud83d\udc1a$> echo Hello World Hello World \ud83d\udc1a/home/ubuntu\ud83d\udc1a$> echo -n Hello World Hello World\ud83d\udc1a/home/ubuntu\ud83d\udc1a$> Imprime o texto fornecido. A op\u00e7\u00e3o -n suprime a nova linha final. Comandos Externos O mini-shell pode executar qualquer comando dispon\u00edvel no PATH do sistema. ls : \ud83d\udc1a/home/ubuntu\ud83d\udc1a$> ls builtin.c index.c index.h mini_shell utils.c \ud83d\udc1a/home/ubuntu\ud83d\udc1a$> ls -l total 60 -rw-r--r-- 1 ubuntu ubuntu 3028 Jun 16 10:00 builtin.c -rw-r--r-- 1 ubuntu ubuntu 5820 Jun 16 10:00 index.c -rw-r--r-- 1 ubuntu ubuntu 1292 Jun 16 10:00 index.h -rwxr-xr-x 1 ubuntu ubuntu 17264 Jun 16 10:00 mini_shell -rw-r--r-- 1 ubuntu ubuntu 3568 Jun 16 10:00 utils.c Lista o conte\u00fado do diret\u00f3rio atual. cat <arquivo> : ```bash \ud83d\udc1a/home/ubuntu\ud83d\udc1a$> cat builtin.c #include \"index.h\" #include int index_exit(char **args){ ... ``` Exibe o conte\u00fado de um arquivo. \"Hello World\" > output.txt \ud83d\udc1a/home/ubuntu\ud83d\udc1a$> cat output.txt Hello World ``` Redirecionamento de Sa\u00edda (Append >> ): Redireciona a sa\u00edda padr\u00e3o de um comando para um arquivo, adicionando ao final. bash \ud83d\udc1a/home/ubuntu\ud83d\udc1a$> echo \"First line\" > append.txt \ud83d\udc1a/home/ubuntu\ud83d\udc1a$> echo \"Second line\" >> append.txt \ud83d\udc1a/home/ubuntu\ud83d\udc1a$> cat append.txt First line Second line","title":"Casos de uso"},{"location":"casos%20de%20uso/#casos-de-uso-detalhados-para-o-mini-shell","text":"","title":"Casos de Uso Detalhados para o Mini-Shell"},{"location":"casos%20de%20uso/#exemplos-de-comandos-testados-e-suas-saidas","text":"O mini-shell suporta a execu\u00e7\u00e3o de comandos built-in e externos, al\u00e9m de redirecionamento de I/O e pipes.","title":"Exemplos de Comandos Testados e Suas Sa\u00eddas"},{"location":"casos%20de%20uso/#comandos-built-in","text":"exit : \ud83d\udc1a/home/ubuntu\ud83d\udc1a$> exit Shutting down... [===========\ud83d\udca5] \u2705 EXIT \u2705 Encerra o mini-shell com uma anima\u00e7\u00e3o de desligamento. env : \ud83d\udc1a/home/ubuntu\ud83d\udc1a$> env TERM=xterm PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin LANG=C.UTF-8 ... (outras vari\u00e1veis de ambiente) Exibe as vari\u00e1veis de ambiente do processo atual. echo <texto> : \ud83d\udc1a/home/ubuntu\ud83d\udc1a$> echo Hello World Hello World \ud83d\udc1a/home/ubuntu\ud83d\udc1a$> echo -n Hello World Hello World\ud83d\udc1a/home/ubuntu\ud83d\udc1a$> Imprime o texto fornecido. A op\u00e7\u00e3o -n suprime a nova linha final.","title":"Comandos Built-in"},{"location":"casos%20de%20uso/#comandos-externos","text":"O mini-shell pode executar qualquer comando dispon\u00edvel no PATH do sistema. ls : \ud83d\udc1a/home/ubuntu\ud83d\udc1a$> ls builtin.c index.c index.h mini_shell utils.c \ud83d\udc1a/home/ubuntu\ud83d\udc1a$> ls -l total 60 -rw-r--r-- 1 ubuntu ubuntu 3028 Jun 16 10:00 builtin.c -rw-r--r-- 1 ubuntu ubuntu 5820 Jun 16 10:00 index.c -rw-r--r-- 1 ubuntu ubuntu 1292 Jun 16 10:00 index.h -rwxr-xr-x 1 ubuntu ubuntu 17264 Jun 16 10:00 mini_shell -rw-r--r-- 1 ubuntu ubuntu 3568 Jun 16 10:00 utils.c Lista o conte\u00fado do diret\u00f3rio atual. cat <arquivo> : ```bash \ud83d\udc1a/home/ubuntu\ud83d\udc1a$> cat builtin.c #include \"index.h\" #include int index_exit(char **args){ ... ``` Exibe o conte\u00fado de um arquivo. \"Hello World\" > output.txt \ud83d\udc1a/home/ubuntu\ud83d\udc1a$> cat output.txt Hello World ``` Redirecionamento de Sa\u00edda (Append >> ): Redireciona a sa\u00edda padr\u00e3o de um comando para um arquivo, adicionando ao final. bash \ud83d\udc1a/home/ubuntu\ud83d\udc1a$> echo \"First line\" > append.txt \ud83d\udc1a/home/ubuntu\ud83d\udc1a$> echo \"Second line\" >> append.txt \ud83d\udc1a/home/ubuntu\ud83d\udc1a$> cat append.txt First line Second line","title":"Comandos Externos"},{"location":"chamadas/","text":"Conceitos Chamadas ao Sistema Utilizadas O mini-shell faz uso extensivo das chamadas abaixo utilizando sistema POSIX para sua opera\u00e7\u00e3o: fork() : Utilizada para criar novos processos filhos, permitindo a execu\u00e7\u00e3o de comandos externos sem encerrar o shell principal. execvp() : Usada pelo processo filho para substituir sua imagem pelo programa do comando digitado. A fun\u00e7\u00e3o procura o execut\u00e1vel no PATH do sistema. wait() : Empregada pelo processo pai para aguardar a conclus\u00e3o de um processo filho, coletando seu status de sa\u00edda e evitando processos zumbis. read() : Implementada para ler a entrada do usu\u00e1rio do stdin , conforme o requisito do projeto. write() : Utilizada para exibir o prompt e outras mensagens na sa\u00edda padr\u00e3o ( stdout ) e erro padr\u00e3o ( stderr ), conforme o requisito do projeto. open() : Usada para abrir arquivos para opera\u00e7\u00f5es de redirecionamento de entrada e sa\u00edda. dup2() : Essencial para implementar o redirecionamento de entrada/sa\u00edda e pipes, duplicando descritores de arquivo. pipe() : Utilizada para criar um pipe de comunica\u00e7\u00e3o entre processos, fundamental para a funcionalidade de pipes. getcwd() : Obt\u00e9m o diret\u00f3rio de trabalho atual para exibir no prompt. malloc() e realloc() : Embora n\u00e3o sejam chamadas de sistema diretamente, s\u00e3o fun\u00e7\u00f5es de gerenciamento de mem\u00f3ria de baixo n\u00edvel que interagem com o sistema para alocar e realocar mem\u00f3ria dinamicamente.","title":"Chamadas ao Sistema"},{"location":"chamadas/#conceitos-chamadas-ao-sistema-utilizadas","text":"","title":"Conceitos Chamadas ao Sistema Utilizadas"},{"location":"chamadas/#o-mini-shell-faz-uso-extensivo-das-chamadas-abaixo-utilizando-sistema-posix-para-sua-operacao","text":"fork() : Utilizada para criar novos processos filhos, permitindo a execu\u00e7\u00e3o de comandos externos sem encerrar o shell principal. execvp() : Usada pelo processo filho para substituir sua imagem pelo programa do comando digitado. A fun\u00e7\u00e3o procura o execut\u00e1vel no PATH do sistema. wait() : Empregada pelo processo pai para aguardar a conclus\u00e3o de um processo filho, coletando seu status de sa\u00edda e evitando processos zumbis. read() : Implementada para ler a entrada do usu\u00e1rio do stdin , conforme o requisito do projeto. write() : Utilizada para exibir o prompt e outras mensagens na sa\u00edda padr\u00e3o ( stdout ) e erro padr\u00e3o ( stderr ), conforme o requisito do projeto. open() : Usada para abrir arquivos para opera\u00e7\u00f5es de redirecionamento de entrada e sa\u00edda. dup2() : Essencial para implementar o redirecionamento de entrada/sa\u00edda e pipes, duplicando descritores de arquivo. pipe() : Utilizada para criar um pipe de comunica\u00e7\u00e3o entre processos, fundamental para a funcionalidade de pipes. getcwd() : Obt\u00e9m o diret\u00f3rio de trabalho atual para exibir no prompt. malloc() e realloc() : Embora n\u00e3o sejam chamadas de sistema diretamente, s\u00e3o fun\u00e7\u00f5es de gerenciamento de mem\u00f3ria de baixo n\u00edvel que interagem com o sistema para alocar e realocar mem\u00f3ria dinamicamente.","title":"O mini-shell faz uso extensivo das chamadas abaixo utilizando sistema POSIX para sua opera\u00e7\u00e3o:"},{"location":"estrutura/","text":"L\u00f3gica Principal do Shell Introdu\u00e7\u00e3o Os arquivos de c\u00f3digo-fonte C que comp\u00f5em a implementa\u00e7\u00e3o de um shell b\u00e1sico. O projeto \u00e9 dividido em m\u00f3dulos, cada um com responsabilidades espec\u00edficas: index.h : Arquivo de cabe\u00e7alho que cont\u00e9m defini\u00e7\u00f5es globais, macros e prot\u00f3tipos de fun\u00e7\u00f5es. utils.c : Implementa fun\u00e7\u00f5es utilit\u00e1rias e wrappers para chamadas de sistema. builtin.c : Cont\u00e9m a implementa\u00e7\u00e3o de comandos built-in do shell. index.c : A l\u00f3gica principal do shell, incluindo o loop de leitura, avalia\u00e7\u00e3o e execu\u00e7\u00e3o de comandos (REPL). index.h - Arquivo de Cabe\u00e7alho Principal O arquivo index.h serve como o cabe\u00e7alho central para o projeto do shell, definindo constantes, incluindo bibliotecas padr\u00e3o, declarando macros e prot\u00f3tipos de fun\u00e7\u00f5es que s\u00e3o utilizadas em m\u00faltiplos arquivos-fonte. Ele estabelece a base para a comunica\u00e7\u00e3o e a coer\u00eancia entre os diferentes m\u00f3dulos do shell. Constantes e C\u00f3digos de Sa\u00edda Este cabe\u00e7alho define c\u00f3digos de sa\u00edda padr\u00e3o que s\u00e3o utilizados em todo o projeto para indicar o status de sucesso ou falha de opera\u00e7\u00f5es. Estes incluem: EX_OK : Representa uma sa\u00edda bem-sucedida, geralmente associada a EXIT_SUCCESS . EX_OSERR : Indica um erro de sistema operacional, como falha na cria\u00e7\u00e3o de um processo ( fork ). EX_UNAVAILABLE : Sinaliza que um comando ou servi\u00e7o n\u00e3o est\u00e1 dispon\u00edvel, como uma falha na execu\u00e7\u00e3o de um programa ( execvp ). Inclus\u00f5es de Bibliotecas Padr\u00e3o Para garantir a funcionalidade completa do shell, index.h inclui v\u00e1rias bibliotecas padr\u00e3o do C, que fornecem acesso a fun\u00e7\u00f5es essenciais para manipula\u00e7\u00e3o de entrada/sa\u00edda, gerenciamento de mem\u00f3ria, opera\u00e7\u00f5es de string e controle de processos: <stdio.h> : Para fun\u00e7\u00f5es de entrada e sa\u00edda, como printf e getline . <stdlib.h> : Para fun\u00e7\u00f5es de uso geral, como aloca\u00e7\u00e3o de mem\u00f3ria ( malloc , realloc , free ) e controle de processos ( exit ). <unistd.h> : Para acesso a chamadas de sistema POSIX, como fork , execvp e getcwd . <string.h> : Para fun\u00e7\u00f5es de manipula\u00e7\u00e3o de strings, como strcmp e strtok . <sys/wait.h> : Para fun\u00e7\u00f5es relacionadas ao controle de processos filhos, como wait e macros para verificar o status de sa\u00edda de processos ( WIFEXITED , WEXITSTATUS ). Utilit\u00e1rios O arquivo index.h define macros que simplificam a formata\u00e7\u00e3o da sa\u00edda do terminal com cores ANSI e facilitam a impress\u00e3o de mensagens. Essas macros s\u00e3o cruciais para melhorar a legibilidade e a experi\u00eancia do usu\u00e1rio no shell: Cores ANSI : Macros como Y (Amarelo), G (Verde), C (Ciano), RED (Vermelho) e RST (Reset) s\u00e3o definidas para aplicar cores ao texto no terminal, tornando as mensagens de status e prompts mais visuais. Prot\u00f3tipos de Fun\u00e7\u00f5es index.h declara os prot\u00f3tipos de todas as fun\u00e7\u00f5es p\u00fablicas que s\u00e3o implementadas nos arquivos .c do projeto. Isso garante que as fun\u00e7\u00f5es possam ser chamadas de outros arquivos sem problemas de compila\u00e7\u00e3o. As fun\u00e7\u00f5es prototipadas incluem: printbanner(void) : Imprime um banner de boas-vindas no in\u00edcio do shell. spinnerLoading() : Exibe uma anima\u00e7\u00e3o de carregamento, geralmente usada antes de sair do shell. Chdir(const char *path) : Wrapper para a fun\u00e7\u00e3o chdir (n\u00e3o implementada nos arquivos fornecidos, mas prototipada). Fork(void) : Wrapper para a fun\u00e7\u00e3o fork , para criar um novo processo. Execvp(const char *file, char *const argv[]) : Wrapper para a fun\u00e7\u00e3o execvp , para executar um programa. Wait(int *status) : Wrapper para a fun\u00e7\u00e3o wait , para aguardar a conclus\u00e3o de um processo filho. Wait(pid_t pid, int *status, int options) : Uma sobrecarga ou declara\u00e7\u00e3o duplicada de Wait , que pode indicar uma inten\u00e7\u00e3o de ter uma fun\u00e7\u00e3o waitpid ou um erro de prototipagem. index_exit(char **) : Implementa\u00e7\u00e3o do comando built-in exit . Getcwd(char *, size_t) : Wrapper para a fun\u00e7\u00e3o getcwd , para obter o diret\u00f3rio de trabalho atual. Malloc(size_t) : Wrapper para a fun\u00e7\u00e3o malloc , para aloca\u00e7\u00e3o de mem\u00f3ria. Realloc(void *ptr, size_t size) : Wrapper para a fun\u00e7\u00e3o realloc , para realoca\u00e7\u00e3o de mem\u00f3ria. Em resumo, index.h \u00e9 o ponto de partida para entender a estrutura e as depend\u00eancias do projeto do shell, fornecendo as defini\u00e7\u00f5es e declara\u00e7\u00f5es necess\u00e1rias para que os diferentes componentes funcionem em conjunto. utils.c - Fun\u00e7\u00f5es Utilit\u00e1rias e Wrappers de Chamadas de Sistema O arquivo utils.c cont\u00e9m uma cole\u00e7\u00e3o de fun\u00e7\u00f5es utilit\u00e1rias e wrappers para chamadas de sistema POSIX. fun\u00e7\u00f5es s\u00e3o projetadas para encapsular a l\u00f3gica de tratamento de erros das chamadas de sistema subjacentes, tornando o c\u00f3digo principal do shell mais limpo e robusto. Em caso de falha, a maioria dessas fun\u00e7\u00f5es imprime uma mensagem de erro usando perror e encerra o programa, garantindo que o shell n\u00e3o continue a operar em um estado inconsistente. Wrappers para Gerenciamento de Processos As fun\u00e7\u00f5es de gerenciamento de processos em utils.c fornecem uma interface segura para opera\u00e7\u00f5es comuns de processos, como cria\u00e7\u00e3o, execu\u00e7\u00e3o e espera: pid_t Fork(void) : Prop\u00f3sito : Este \u00e9 um wrapper para a chamada de sistema fork() . Ele cria um novo processo filho que \u00e9 uma c\u00f3pia exata do processo pai. Comportamento em Erro : Se fork() falhar (retornar um valor negativo), a fun\u00e7\u00e3o imprime uma mensagem de erro ( \"Fork Failed\" ) usando perror e encerra o programa com exit(EX_OSERR) . Isso garante que o shell n\u00e3o tente operar com um processo filho que n\u00e3o foi criado corretamente. Retorno : Retorna o ID do processo filho ( pid_t ) para o processo pai e 0 para o processo filho, conforme o comportamento padr\u00e3o de fork() . void Execvp(const char *file, char *const argv[]) : Prop\u00f3sito : Este wrapper para execvp() substitui a imagem do processo atual por um novo programa. Ele procura o execut\u00e1vel especificado por file nos diret\u00f3rios listados na vari\u00e1vel de ambiente PATH . Comportamento em Erro : Antes de chamar execvp() , a fun\u00e7\u00e3o verifica se file ou argv s\u00e3o nulos. Se forem, imprime uma mensagem de erro no stderr e encerra com exit(EXIT_FAILURE) . Se execvp() falhar (retornar -1 ), imprime uma mensagem de erro ( \"Failed\" ) usando perror e encerra o programa com exit(EX_UNAVAILABLE) . Isso \u00e9 crucial porque execvp() s\u00f3 retorna em caso de erro; um retorno bem-sucedido significa que o novo programa est\u00e1 em execu\u00e7\u00e3o. Argumentos : file \u00e9 o nome do programa a ser executado, e argv \u00e9 um array de strings que representa os argumentos da linha de comando para o novo programa, onde argv[0] \u00e9 o nome do programa. pid_t Wait(int *status) : Prop\u00f3sito : Este wrapper para wait() suspende a execu\u00e7\u00e3o do processo pai at\u00e9 que um de seus processos filhos termine. Ele \u00e9 usado para coletar o status de sa\u00edda de processos filhos e evitar processos zumbis. Comportamento em Erro : A fun\u00e7\u00e3o primeiro verifica se o ponteiro status \u00e9 nulo. Se for, imprime uma mensagem de erro ( \"Wait: status argument required\" ) e retorna -1 . Se wait() falhar (retornar -1 ), imprime uma mensagem de erro ( \"Wait failed\" ) usando perror . Ap\u00f3s a conclus\u00e3o bem-sucedida de wait() , se o processo filho terminou normalmente ( WIFEXITED(*status) ), o status de sa\u00edda real do filho ( WEXITSTATUS(*status) ) \u00e9 armazenado em *status . Retorno : Retorna o ID do processo filho que terminou ou -1 em caso de erro. Wrappers para Gerenciamento de Mem\u00f3ria As fun\u00e7\u00f5es de gerenciamento de mem\u00f3ria em utils.c fornecem aloca\u00e7\u00e3o e realoca\u00e7\u00e3o de mem\u00f3ria seguras, com tratamento de erros integrado: void *Malloc(size_t size) : Prop\u00f3sito : Este wrapper para malloc() aloca um bloco de mem\u00f3ria do tamanho especificado. Comportamento em Erro : Se malloc() falhar (retornar NULL ), a fun\u00e7\u00e3o imprime uma mensagem de erro ( \"Malloc Failed\" ) usando perror e encerra o programa com exit(EXIT_FAILURE) . Um caso especial \u00e9 quando size \u00e9 0 , para o qual Malloc retorna NULL sem erro, seguindo o comportamento comum de malloc para aloca\u00e7\u00f5es de tamanho zero. Retorno : Retorna um ponteiro para o bloco de mem\u00f3ria alocado ou NULL se size for 0 . void *Realloc(void *ptr, size_t size) : Prop\u00f3sito : Este wrapper para realloc() redimensiona o bloco de mem\u00f3ria apontado por ptr para o novo size . Comportamento em Erro : Se realloc() falhar (retornar NULL ) e o size n\u00e3o for 0 , a fun\u00e7\u00e3o imprime uma mensagem de erro ( \"Realloc Failed\" ) usando perror e encerra o programa com exit(EXIT_FAILURE) . Se size for 0 , realloc se comporta como free(ptr) , e a fun\u00e7\u00e3o retorna NULL sem erro, o que \u00e9 um comportamento v\u00e1lido. Retorno : Retorna um ponteiro para o bloco de mem\u00f3ria redimensionado ou NULL se a realoca\u00e7\u00e3o falhar ou se size for 0 . Wrappers para Opera\u00e7\u00f5es de Diret\u00f3rio utils.c inclui um wrapper para obter o diret\u00f3rio de trabalho atual: void Getcwd(char *buf, size_t size) : Prop\u00f3sito : Este wrapper para getcwd() copia o caminho absoluto do diret\u00f3rio de trabalho atual para o buffer buf . Comportamento em Erro : Se getcwd() falhar (retornar NULL ), a fun\u00e7\u00e3o imprime uma mensagem de erro ( \"getcwd FAILED\" ) usando perror . Argumentos : buf \u00e9 o buffer onde o caminho ser\u00e1 armazenado, e size \u00e9 o tamanho m\u00e1ximo do buffer. Fun\u00e7\u00f5es de Interface do Usu\u00e1rio Al\u00e9m dos wrappers, utils.c tamb\u00e9m cont\u00e9m fun\u00e7\u00f5es para melhorar a experi\u00eancia do usu\u00e1rio com elementos visuais: void printbanner(void) : Prop\u00f3sito : Imprime um banner ASCII art no console. Este banner \u00e9 exibido no in\u00edcio do shell, fornecendo uma sauda\u00e7\u00e3o visual. Implementa\u00e7\u00e3o : Utiliza a macro p (que envolve printf ) e c\u00f3digos de cores ANSI (definidos em index.h ) para exibir o banner com formata\u00e7\u00e3o colorida. void spinnerLoading() : Prop\u00f3sito : Exibe uma anima\u00e7\u00e3o de \"carregamento\" ou \"desligamento\" no console, simulando um processo em andamento antes de o shell ser encerrado. Implementa\u00e7\u00e3o : A fun\u00e7\u00e3o usa um array de strings ( charging[] ) para representar os diferentes quadros da anima\u00e7\u00e3o de um spinner. Ela itera sobre esses quadros, imprimindo cada um com um atraso ( usleep ) e for\u00e7ando a atualiza\u00e7\u00e3o do console ( fflush(stdout) ). No final da anima\u00e7\u00e3o, imprime uma mensagem de sa\u00edda e encerra o programa com exit(X_OK) (onde X_OK \u00e9 uma constante definida em index.h como EX_OK ). Em resumo, utils.c \u00e9 um componente vital do shell, fornecendo uma camada de abstra\u00e7\u00e3o e tratamento de erros para opera\u00e7\u00f5es de baixo n\u00edvel, o que contribui significativamente para a robustez e a confiabilidade do sistema. builtin.c - Implementa\u00e7\u00e3o de Comandos Built-in O arquivo builtin.c \u00e9 respons\u00e1vel por implementar os comandos built-in do shell que s\u00e3o fun\u00e7\u00f5es que s\u00e3o executadas diretamente pelo shell, em vez de serem programas externos. e n\u00e3o exigem a cria\u00e7\u00e3o de um novo processo. Este projeto cont\u00e9m as implementa\u00e7\u00f5es para os comandos exit e env . int index_exit(char **args) Prop\u00f3sito : Implementa o comando exit , que encerra a execu\u00e7\u00e3o do shell. Funcionalidade : Antes de sair, a fun\u00e7\u00e3o chama spinnerLoading() , que exibe uma anima\u00e7\u00e3o de desligamento, proporcionando uma experi\u00eancia de usu\u00e1rio mais agrad\u00e1vel. Ap\u00f3s a anima\u00e7\u00e3o, o shell \u00e9 encerrado com exit(EXIT_SUCCESS) , indicando uma sa\u00edda bem-sucedida. int index_env(char **args) Prop\u00f3sito : Implementa o comando env , que exibe as vari\u00e1veis de ambiente do processo atual. Funcionalidade : A fun\u00e7\u00e3o acessa a vari\u00e1vel global environ (declarada como extern char **environ; ), que \u00e9 um ponteiro para um array de strings, onde cada string representa uma vari\u00e1vel de ambiente no formato NOME=VALOR . A fun\u00e7\u00e3o itera sobre este array e imprime cada vari\u00e1vel de ambiente em uma nova linha usando a macro p (que envolve printf ). int cell_echo(char **args) Prop\u00f3sito : Implementa o comando echo , que imprime os argumentos fornecidos na sa\u00edda padr\u00e3o. Suporta a op\u00e7\u00e3o -n para suprimir a nova linha final. Funcionalidade : A fun\u00e7\u00e3o verifica se o segundo argumento ( args[1] ) \u00e9 \"-n\" . Se for, a flag newline \u00e9 definida como false e o \u00edndice de in\u00edcio para a impress\u00e3o dos argumentos \u00e9 ajustado para 2 (pulando echo e -n ). Caso contr\u00e1rio, a impress\u00e3o come\u00e7a do \u00edndice 1 . A fun\u00e7\u00e3o ent\u00e3o itera sobre os argumentos restantes, imprimindo cada um. Um espa\u00e7o \u00e9 adicionado entre os argumentos. Finalmente, se a flag newline for true , uma nova linha \u00e9 impressa. Este arquivo centraliza a l\u00f3gica para comandos que s\u00e3o parte integrante do shell, garantindo que eles sejam executados de forma eficiente e com o comportamento esperado. index.c - L\u00f3gica Principal do Shell (REPL) O arquivo index.c cont\u00e9m a l\u00f3gica central do shell, implementando o ciclo REPL (Read-Evaluate-Print/Execute-Loop). Este ciclo \u00e9 o cora\u00e7\u00e3o de qualquer shell interativo, onde o programa l\u00ea a entrada do usu\u00e1rio, a processa, executa o comando correspondente e repete o processo. Al\u00e9m do REPL, index.c gerencia a execu\u00e7\u00e3o de comandos built-in e externos, bem como a divis\u00e3o da linha de comando em argumentos. Vari\u00e1veis Globais int status = 0; : Prop\u00f3sito : Esta vari\u00e1vel global armazena o status de sa\u00edda do \u00faltimo comando executado. \u00c9 um padr\u00e3o comum em shells para que o status de sa\u00edda possa ser consultado por comandos subsequentes ou scripts. Fun\u00e7\u00f5es de Execu\u00e7\u00e3o de Comandos void index_launch(char **args) : Prop\u00f3sito : Esta fun\u00e7\u00e3o \u00e9 respons\u00e1vel por lan\u00e7ar a execu\u00e7\u00e3o de comandos externos (n\u00e3o built-in). Funcionalidade : Ela utiliza o wrapper Fork() para criar um novo processo filho. Se for o processo filho ( INDEX_jr \u00e9 0, conforme definido em index.h ), ele chama Execvp(args[0], args) para substituir a imagem do processo filho pelo programa especificado em args[0] com seus respectivos argumentos. Se for o processo pai, ele chama Wait(&status) para aguardar a conclus\u00e3o do processo filho e coletar seu status de sa\u00edda, que \u00e9 armazenado na vari\u00e1vel global status . Fluxo de Controle : Esta fun\u00e7\u00e3o \u00e9 crucial para a capacidade do shell de executar programas externos, como ls , grep , etc. void index_exec(char **args) : Prop\u00f3sito : Esta \u00e9 a fun\u00e7\u00e3o principal para a execu\u00e7\u00e3o de comandos, atuando como um despachante para comandos built-in e externos. Funcionalidade : A fun\u00e7\u00e3o itera sobre a estrutura global g_builtin (definida em index.c e populada com os comandos built-in). Para cada entrada em g_builtin , ela compara o nome do comando built-in ( g_builtin[i].builtin_name ) com o primeiro argumento da linha de comando ( args[0] ) usando strcmp . Se uma correspond\u00eancia for encontrada, a fun\u00e7\u00e3o associada ao built-in ( g_builtin[i].foo ) \u00e9 chamada com os argumentos, e o valor de retorno (status de sa\u00edda do built-in) \u00e9 armazenado na vari\u00e1vel global status . Ap\u00f3s a execu\u00e7\u00e3o do built-in, a fun\u00e7\u00e3o retorna. Comandos Built-in : A estrutura g_builtin \u00e9 um array de t_builtin (definido em index.h ), que mapeia nomes de comandos para ponteiros de fun\u00e7\u00e3o. Atualmente, inclui env e exit . A linha comentada {.builtin_name =\"echo\", .foo=index_echo}; sugere que echo foi considerado ou pode ser adicionado no futuro. Execu\u00e7\u00e3o de Comandos Externos : Se nenhum comando built-in corresponder ao args[0] , a fun\u00e7\u00e3o index_launch(args) \u00e9 chamada para tentar executar o comando como um programa externo. Fun\u00e7\u00f5es de Processamento de Entrada char **index_split_line(char *line) : Prop\u00f3sito : Esta fun\u00e7\u00e3o \u00e9 respons\u00e1vel por tokenizar a linha de entrada do usu\u00e1rio em argumentos individuais. Funcionalidade : Ela utiliza a fun\u00e7\u00e3o strtok para dividir a string line em tokens, usando os delimitadores definidos pela macro DEL (espa\u00e7o, tabula\u00e7\u00e3o, nova linha, etc.). A fun\u00e7\u00e3o aloca dinamicamente mem\u00f3ria para armazenar os ponteiros para esses tokens. Se a capacidade do buffer for excedida, Realloc \u00e9 usado para dobrar o tamanho do buffer, garantindo que todos os tokens possam ser armazenados. O array de tokens \u00e9 terminado com NULL , o que \u00e9 um padr\u00e3o comum para arrays de strings em C. Gerenciamento de Mem\u00f3ria : A mem\u00f3ria para os tokens \u00e9 alocada usando Malloc e Realloc , garantindo tratamento de erros para falhas de aloca\u00e7\u00e3o. Retorno : Retorna um array de strings ( char ** ) onde cada string \u00e9 um argumento da linha de comando. char *index_read_line(void) : Prop\u00f3sito : Esta fun\u00e7\u00e3o l\u00ea uma linha de entrada do usu\u00e1rio do stdin . Funcionalidade : Ela exibe um prompt para o usu\u00e1rio, que inclui o diret\u00f3rio de trabalho atual (obtido via Getcwd ) e um caractere de shell ( \ud83d\udc1a ). Em seguida, usa getline para ler a linha completa, incluindo espa\u00e7os, at\u00e9 que uma nova linha seja encontrada ou o final do arquivo seja atingido. getline aloca dinamicamente o buffer buf conforme necess\u00e1rio. Tratamento de Erros : Se getline falhar (retornar -1 ), a fun\u00e7\u00e3o libera o buffer alocado e verifica se o final do arquivo ( feof(stdin) ) foi atingido. Se sim, imprime \"[EOF]\" ; caso contr\u00e1rio, imprime \"getline failed\" . Retorno : Retorna um ponteiro para a string lida ou NULL em caso de erro ou final de arquivo. Fun\u00e7\u00e3o Principal ( main ) int main() : Prop\u00f3sito : A fun\u00e7\u00e3o main \u00e9 o ponto de entrada do programa shell e implementa o loop REPL. Fluxo de Execu\u00e7\u00e3o : Banner : Chama printbanner() para exibir uma mensagem de boas-vindas no in\u00edcio. Loop REPL : Entra em um loop infinito ( while((line = index_read_line())) ) que continua enquanto index_read_line() retornar uma linha v\u00e1lida (ou seja, n\u00e3o NULL ). Leitura (Read) : Dentro do loop, index_read_line() \u00e9 chamada para obter a entrada do usu\u00e1rio, exibindo o prompt e lendo a linha. Avalia\u00e7\u00e3o/Tokeniza\u00e7\u00e3o (Evaluate/Lexing/Parsing) : A linha lida \u00e9 ent\u00e3o passada para index_split_line(line) para ser tokenizada em argumentos. Execu\u00e7\u00e3o (Execute) : Os argumentos tokenizados s\u00e3o passados para index_exec(args) , que decide se o comando \u00e9 um built-in ou um programa externo e o executa. Libera\u00e7\u00e3o de Mem\u00f3ria (Free) : Ap\u00f3s a execu\u00e7\u00e3o do comando, a mem\u00f3ria alocada para a linha ( line ) e os argumentos ( args ) \u00e9 liberada usando free() , prevenindo vazamentos de mem\u00f3ria. Loop (Loop) : O ciclo se repete, solicitando uma nova entrada do usu\u00e1rio. Sa\u00edda : O loop termina quando index_read_line() retorna NULL (indicando EOF ou um erro fatal). O programa ent\u00e3o retorna EXIT_SUCCESS . Estrutura g_builtin t_builtin g_builtin[] = { // {.builtin_name =\"echo\", .foo=index_echo}; {.builtin_name =\"env\", .foo=index_env}; {.builtin_name =\"exit\", .foo=index_exit}, {.builtin_name =NULL} }; Prop\u00f3sito : Esta \u00e9 uma vari\u00e1vel global que armazena a lista de comandos built-in que o shell suporta. \u00c9 um array de estruturas t_builtin , onde cada elemento associa o nome de um comando built-in a um ponteiro para a fun\u00e7\u00e3o que o implementa. Extensibilidade : A estrutura \u00e9 terminada com um elemento NULL , permitindo que o shell itere sobre ela para encontrar o comando built-in correto. Novas fun\u00e7\u00f5es built-in podem ser adicionadas a este array para estender a funcionalidade do shell. Em resumo, index.c orquestra o fluxo de trabalho do shell, desde a intera\u00e7\u00e3o com o usu\u00e1rio at\u00e9 a execu\u00e7\u00e3o de comandos, garantindo que o shell funcione como um ambiente de linha de comando interativo e responsivo. Conclus\u00e3o O projeto de shell em C analisado demonstra uma implementa\u00e7\u00e3o funcional de um interpretador de linha de comando b\u00e1sico. A arquitetura modular, com responsabilidades bem definidas para cada arquivo ( index.h , utils.c , builtin.c , index.c ), contribui para a clareza e manutenibilidade do c\u00f3digo. Os principais recursos implementados incluem: Loop REPL : O shell l\u00ea comandos do usu\u00e1rio, os avalia e os executa, repetindo o ciclo. Execu\u00e7\u00e3o de Comandos Externos : Capacidade de executar programas do sistema operacional atrav\u00e9s de fork e execvp . Comandos Built-in : Implementa\u00e7\u00e3o de comandos internos como exit e env , que s\u00e3o executados diretamente pelo shell para maior efici\u00eancia. Tokeniza\u00e7\u00e3o de Linha de Comando : A entrada do usu\u00e1rio \u00e9 dividida em tokens (comandos e argumentos) para processamento. Gerenciamento de Processos : Utiliza\u00e7\u00e3o de fork , execvp e wait para criar e gerenciar processos filhos. Gerenciamento de Mem\u00f3ria : Uso de malloc e realloc com wrappers para tratamento de erros, garantindo aloca\u00e7\u00e3o e realoca\u00e7\u00e3o de mem\u00f3ria seguras. Interface de Usu\u00e1rio Aprimorada : Uso de cores ANSI para prompts e mensagens, al\u00e9m de um banner de boas-vindas e uma anima\u00e7\u00e3o de desligamento. O c\u00f3digo demonstra boas pr\u00e1ticas de programa\u00e7\u00e3o em C, como o uso de wrappers para chamadas de sistema para centralizar o tratamento de erros e a libera\u00e7\u00e3o de mem\u00f3ria alocada dinamicamente para evitar vazamentos. Poss\u00edveis Melhorias e Extens\u00f5es Embora funcional, o shell pode ser estendido com recursos adicionais para torn\u00e1-lo mais robusto e completo, como: Redirecionamento de Entrada/Sa\u00edda : Implementar operadores como > , < , >> e | (pipes). Tratamento de Sinais : Melhorar o tratamento de sinais como SIGINT (Ctrl+C) e SIGTSTP (Ctrl+Z). Vari\u00e1veis de Shell : Permitir a defini\u00e7\u00e3o e o uso de vari\u00e1veis de ambiente locais ao shell. Hist\u00f3rico de Comandos : Implementar um hist\u00f3rico de comandos naveg\u00e1vel. Autocompletar : Adicionar funcionalidade de autocompletar para comandos e nomes de arquivos. Aliases : Permitir a cria\u00e7\u00e3o de aliases para comandos. Jobs em Background : Suporte para executar comandos em segundo plano (usando & ). Scripting : Capacidade de executar scripts de shell. Limita\u00e7\u00f5es Conhecidas da Implementa\u00e7\u00e3o Esta vers\u00e3o do mini-shell possui algumas limita\u00e7\u00f5es: Comandos Built-in Fixos : A lista de comandos built-in ( env , exit , echo ) \u00e9 fixa e n\u00e3o pode ser estendida dinamicamente em tempo de execu\u00e7\u00e3o. Aus\u00eancia de Vari\u00e1veis de Ambiente do Shell : N\u00e3o h\u00e1 suporte para vari\u00e1veis de ambiente internas do shell (ex: $PATH , $HOME ) que podem ser definidas e usadas dentro do shell. Sem Hist\u00f3rico de Comandos : N\u00e3o h\u00e1 funcionalidade de hist\u00f3rico de comandos (setas para cima/baixo). Sem Autocompletar : N\u00e3o h\u00e1 suporte para autocompletar nomes de arquivos ou comandos. Tratamento B\u00e1sico de Erros : Embora perror seja usado para erros de chamadas de sistema, o tratamento de erros para comandos n\u00e3o encontrados \u00e9 gen\u00e9rico (\"Command not found\") e n\u00e3o fornece detalhes espec\u00edficos sobre o motivo da falha (ex: permiss\u00e3o negada, comando inexistente). Aus\u00eancia de Comandos Complexos : N\u00e3o h\u00e1 suporte para estruturas de controle de fluxo (if, for, while), execu\u00e7\u00e3o em segundo plano ( & ), ou encadeamento de comandos com && ou || . Gerenciamento de Jobs : N\u00e3o h\u00e1 suporte para gerenciamento de jobs (suspender, retomar processos).","title":"Explica\u00e7\u00e3o da Estrutura"},{"location":"estrutura/#logica-principal-do-shell","text":"","title":"L\u00f3gica Principal do Shell"},{"location":"estrutura/#introducao","text":"Os arquivos de c\u00f3digo-fonte C que comp\u00f5em a implementa\u00e7\u00e3o de um shell b\u00e1sico. O projeto \u00e9 dividido em m\u00f3dulos, cada um com responsabilidades espec\u00edficas: index.h : Arquivo de cabe\u00e7alho que cont\u00e9m defini\u00e7\u00f5es globais, macros e prot\u00f3tipos de fun\u00e7\u00f5es. utils.c : Implementa fun\u00e7\u00f5es utilit\u00e1rias e wrappers para chamadas de sistema. builtin.c : Cont\u00e9m a implementa\u00e7\u00e3o de comandos built-in do shell. index.c : A l\u00f3gica principal do shell, incluindo o loop de leitura, avalia\u00e7\u00e3o e execu\u00e7\u00e3o de comandos (REPL).","title":"Introdu\u00e7\u00e3o"},{"location":"estrutura/#indexh-arquivo-de-cabecalho-principal","text":"O arquivo index.h serve como o cabe\u00e7alho central para o projeto do shell, definindo constantes, incluindo bibliotecas padr\u00e3o, declarando macros e prot\u00f3tipos de fun\u00e7\u00f5es que s\u00e3o utilizadas em m\u00faltiplos arquivos-fonte. Ele estabelece a base para a comunica\u00e7\u00e3o e a coer\u00eancia entre os diferentes m\u00f3dulos do shell.","title":"index.h - Arquivo de Cabe\u00e7alho Principal"},{"location":"estrutura/#constantes-e-codigos-de-saida","text":"Este cabe\u00e7alho define c\u00f3digos de sa\u00edda padr\u00e3o que s\u00e3o utilizados em todo o projeto para indicar o status de sucesso ou falha de opera\u00e7\u00f5es. Estes incluem: EX_OK : Representa uma sa\u00edda bem-sucedida, geralmente associada a EXIT_SUCCESS . EX_OSERR : Indica um erro de sistema operacional, como falha na cria\u00e7\u00e3o de um processo ( fork ). EX_UNAVAILABLE : Sinaliza que um comando ou servi\u00e7o n\u00e3o est\u00e1 dispon\u00edvel, como uma falha na execu\u00e7\u00e3o de um programa ( execvp ).","title":"Constantes e C\u00f3digos de Sa\u00edda"},{"location":"estrutura/#inclusoes-de-bibliotecas-padrao","text":"Para garantir a funcionalidade completa do shell, index.h inclui v\u00e1rias bibliotecas padr\u00e3o do C, que fornecem acesso a fun\u00e7\u00f5es essenciais para manipula\u00e7\u00e3o de entrada/sa\u00edda, gerenciamento de mem\u00f3ria, opera\u00e7\u00f5es de string e controle de processos: <stdio.h> : Para fun\u00e7\u00f5es de entrada e sa\u00edda, como printf e getline . <stdlib.h> : Para fun\u00e7\u00f5es de uso geral, como aloca\u00e7\u00e3o de mem\u00f3ria ( malloc , realloc , free ) e controle de processos ( exit ). <unistd.h> : Para acesso a chamadas de sistema POSIX, como fork , execvp e getcwd . <string.h> : Para fun\u00e7\u00f5es de manipula\u00e7\u00e3o de strings, como strcmp e strtok . <sys/wait.h> : Para fun\u00e7\u00f5es relacionadas ao controle de processos filhos, como wait e macros para verificar o status de sa\u00edda de processos ( WIFEXITED , WEXITSTATUS ).","title":"Inclus\u00f5es de Bibliotecas Padr\u00e3o"},{"location":"estrutura/#utilitarios","text":"O arquivo index.h define macros que simplificam a formata\u00e7\u00e3o da sa\u00edda do terminal com cores ANSI e facilitam a impress\u00e3o de mensagens. Essas macros s\u00e3o cruciais para melhorar a legibilidade e a experi\u00eancia do usu\u00e1rio no shell: Cores ANSI : Macros como Y (Amarelo), G (Verde), C (Ciano), RED (Vermelho) e RST (Reset) s\u00e3o definidas para aplicar cores ao texto no terminal, tornando as mensagens de status e prompts mais visuais.","title":"Utilit\u00e1rios"},{"location":"estrutura/#prototipos-de-funcoes","text":"index.h declara os prot\u00f3tipos de todas as fun\u00e7\u00f5es p\u00fablicas que s\u00e3o implementadas nos arquivos .c do projeto. Isso garante que as fun\u00e7\u00f5es possam ser chamadas de outros arquivos sem problemas de compila\u00e7\u00e3o. As fun\u00e7\u00f5es prototipadas incluem: printbanner(void) : Imprime um banner de boas-vindas no in\u00edcio do shell. spinnerLoading() : Exibe uma anima\u00e7\u00e3o de carregamento, geralmente usada antes de sair do shell. Chdir(const char *path) : Wrapper para a fun\u00e7\u00e3o chdir (n\u00e3o implementada nos arquivos fornecidos, mas prototipada). Fork(void) : Wrapper para a fun\u00e7\u00e3o fork , para criar um novo processo. Execvp(const char *file, char *const argv[]) : Wrapper para a fun\u00e7\u00e3o execvp , para executar um programa. Wait(int *status) : Wrapper para a fun\u00e7\u00e3o wait , para aguardar a conclus\u00e3o de um processo filho. Wait(pid_t pid, int *status, int options) : Uma sobrecarga ou declara\u00e7\u00e3o duplicada de Wait , que pode indicar uma inten\u00e7\u00e3o de ter uma fun\u00e7\u00e3o waitpid ou um erro de prototipagem. index_exit(char **) : Implementa\u00e7\u00e3o do comando built-in exit . Getcwd(char *, size_t) : Wrapper para a fun\u00e7\u00e3o getcwd , para obter o diret\u00f3rio de trabalho atual. Malloc(size_t) : Wrapper para a fun\u00e7\u00e3o malloc , para aloca\u00e7\u00e3o de mem\u00f3ria. Realloc(void *ptr, size_t size) : Wrapper para a fun\u00e7\u00e3o realloc , para realoca\u00e7\u00e3o de mem\u00f3ria. Em resumo, index.h \u00e9 o ponto de partida para entender a estrutura e as depend\u00eancias do projeto do shell, fornecendo as defini\u00e7\u00f5es e declara\u00e7\u00f5es necess\u00e1rias para que os diferentes componentes funcionem em conjunto.","title":"Prot\u00f3tipos de Fun\u00e7\u00f5es"},{"location":"estrutura/#utilsc-funcoes-utilitarias-e-wrappers-de-chamadas-de-sistema","text":"O arquivo utils.c cont\u00e9m uma cole\u00e7\u00e3o de fun\u00e7\u00f5es utilit\u00e1rias e wrappers para chamadas de sistema POSIX. fun\u00e7\u00f5es s\u00e3o projetadas para encapsular a l\u00f3gica de tratamento de erros das chamadas de sistema subjacentes, tornando o c\u00f3digo principal do shell mais limpo e robusto. Em caso de falha, a maioria dessas fun\u00e7\u00f5es imprime uma mensagem de erro usando perror e encerra o programa, garantindo que o shell n\u00e3o continue a operar em um estado inconsistente.","title":"utils.c - Fun\u00e7\u00f5es Utilit\u00e1rias e Wrappers de Chamadas de Sistema"},{"location":"estrutura/#wrappers-para-gerenciamento-de-processos","text":"As fun\u00e7\u00f5es de gerenciamento de processos em utils.c fornecem uma interface segura para opera\u00e7\u00f5es comuns de processos, como cria\u00e7\u00e3o, execu\u00e7\u00e3o e espera: pid_t Fork(void) : Prop\u00f3sito : Este \u00e9 um wrapper para a chamada de sistema fork() . Ele cria um novo processo filho que \u00e9 uma c\u00f3pia exata do processo pai. Comportamento em Erro : Se fork() falhar (retornar um valor negativo), a fun\u00e7\u00e3o imprime uma mensagem de erro ( \"Fork Failed\" ) usando perror e encerra o programa com exit(EX_OSERR) . Isso garante que o shell n\u00e3o tente operar com um processo filho que n\u00e3o foi criado corretamente. Retorno : Retorna o ID do processo filho ( pid_t ) para o processo pai e 0 para o processo filho, conforme o comportamento padr\u00e3o de fork() . void Execvp(const char *file, char *const argv[]) : Prop\u00f3sito : Este wrapper para execvp() substitui a imagem do processo atual por um novo programa. Ele procura o execut\u00e1vel especificado por file nos diret\u00f3rios listados na vari\u00e1vel de ambiente PATH . Comportamento em Erro : Antes de chamar execvp() , a fun\u00e7\u00e3o verifica se file ou argv s\u00e3o nulos. Se forem, imprime uma mensagem de erro no stderr e encerra com exit(EXIT_FAILURE) . Se execvp() falhar (retornar -1 ), imprime uma mensagem de erro ( \"Failed\" ) usando perror e encerra o programa com exit(EX_UNAVAILABLE) . Isso \u00e9 crucial porque execvp() s\u00f3 retorna em caso de erro; um retorno bem-sucedido significa que o novo programa est\u00e1 em execu\u00e7\u00e3o. Argumentos : file \u00e9 o nome do programa a ser executado, e argv \u00e9 um array de strings que representa os argumentos da linha de comando para o novo programa, onde argv[0] \u00e9 o nome do programa. pid_t Wait(int *status) : Prop\u00f3sito : Este wrapper para wait() suspende a execu\u00e7\u00e3o do processo pai at\u00e9 que um de seus processos filhos termine. Ele \u00e9 usado para coletar o status de sa\u00edda de processos filhos e evitar processos zumbis. Comportamento em Erro : A fun\u00e7\u00e3o primeiro verifica se o ponteiro status \u00e9 nulo. Se for, imprime uma mensagem de erro ( \"Wait: status argument required\" ) e retorna -1 . Se wait() falhar (retornar -1 ), imprime uma mensagem de erro ( \"Wait failed\" ) usando perror . Ap\u00f3s a conclus\u00e3o bem-sucedida de wait() , se o processo filho terminou normalmente ( WIFEXITED(*status) ), o status de sa\u00edda real do filho ( WEXITSTATUS(*status) ) \u00e9 armazenado em *status . Retorno : Retorna o ID do processo filho que terminou ou -1 em caso de erro.","title":"Wrappers para Gerenciamento de Processos"},{"location":"estrutura/#wrappers-para-gerenciamento-de-memoria","text":"As fun\u00e7\u00f5es de gerenciamento de mem\u00f3ria em utils.c fornecem aloca\u00e7\u00e3o e realoca\u00e7\u00e3o de mem\u00f3ria seguras, com tratamento de erros integrado: void *Malloc(size_t size) : Prop\u00f3sito : Este wrapper para malloc() aloca um bloco de mem\u00f3ria do tamanho especificado. Comportamento em Erro : Se malloc() falhar (retornar NULL ), a fun\u00e7\u00e3o imprime uma mensagem de erro ( \"Malloc Failed\" ) usando perror e encerra o programa com exit(EXIT_FAILURE) . Um caso especial \u00e9 quando size \u00e9 0 , para o qual Malloc retorna NULL sem erro, seguindo o comportamento comum de malloc para aloca\u00e7\u00f5es de tamanho zero. Retorno : Retorna um ponteiro para o bloco de mem\u00f3ria alocado ou NULL se size for 0 . void *Realloc(void *ptr, size_t size) : Prop\u00f3sito : Este wrapper para realloc() redimensiona o bloco de mem\u00f3ria apontado por ptr para o novo size . Comportamento em Erro : Se realloc() falhar (retornar NULL ) e o size n\u00e3o for 0 , a fun\u00e7\u00e3o imprime uma mensagem de erro ( \"Realloc Failed\" ) usando perror e encerra o programa com exit(EXIT_FAILURE) . Se size for 0 , realloc se comporta como free(ptr) , e a fun\u00e7\u00e3o retorna NULL sem erro, o que \u00e9 um comportamento v\u00e1lido. Retorno : Retorna um ponteiro para o bloco de mem\u00f3ria redimensionado ou NULL se a realoca\u00e7\u00e3o falhar ou se size for 0 .","title":"Wrappers para Gerenciamento de Mem\u00f3ria"},{"location":"estrutura/#wrappers-para-operacoes-de-diretorio","text":"utils.c inclui um wrapper para obter o diret\u00f3rio de trabalho atual: void Getcwd(char *buf, size_t size) : Prop\u00f3sito : Este wrapper para getcwd() copia o caminho absoluto do diret\u00f3rio de trabalho atual para o buffer buf . Comportamento em Erro : Se getcwd() falhar (retornar NULL ), a fun\u00e7\u00e3o imprime uma mensagem de erro ( \"getcwd FAILED\" ) usando perror . Argumentos : buf \u00e9 o buffer onde o caminho ser\u00e1 armazenado, e size \u00e9 o tamanho m\u00e1ximo do buffer.","title":"Wrappers para Opera\u00e7\u00f5es de Diret\u00f3rio"},{"location":"estrutura/#funcoes-de-interface-do-usuario","text":"Al\u00e9m dos wrappers, utils.c tamb\u00e9m cont\u00e9m fun\u00e7\u00f5es para melhorar a experi\u00eancia do usu\u00e1rio com elementos visuais: void printbanner(void) : Prop\u00f3sito : Imprime um banner ASCII art no console. Este banner \u00e9 exibido no in\u00edcio do shell, fornecendo uma sauda\u00e7\u00e3o visual. Implementa\u00e7\u00e3o : Utiliza a macro p (que envolve printf ) e c\u00f3digos de cores ANSI (definidos em index.h ) para exibir o banner com formata\u00e7\u00e3o colorida. void spinnerLoading() : Prop\u00f3sito : Exibe uma anima\u00e7\u00e3o de \"carregamento\" ou \"desligamento\" no console, simulando um processo em andamento antes de o shell ser encerrado. Implementa\u00e7\u00e3o : A fun\u00e7\u00e3o usa um array de strings ( charging[] ) para representar os diferentes quadros da anima\u00e7\u00e3o de um spinner. Ela itera sobre esses quadros, imprimindo cada um com um atraso ( usleep ) e for\u00e7ando a atualiza\u00e7\u00e3o do console ( fflush(stdout) ). No final da anima\u00e7\u00e3o, imprime uma mensagem de sa\u00edda e encerra o programa com exit(X_OK) (onde X_OK \u00e9 uma constante definida em index.h como EX_OK ). Em resumo, utils.c \u00e9 um componente vital do shell, fornecendo uma camada de abstra\u00e7\u00e3o e tratamento de erros para opera\u00e7\u00f5es de baixo n\u00edvel, o que contribui significativamente para a robustez e a confiabilidade do sistema.","title":"Fun\u00e7\u00f5es de Interface do Usu\u00e1rio"},{"location":"estrutura/#builtinc-implementacao-de-comandos-built-in","text":"O arquivo builtin.c \u00e9 respons\u00e1vel por implementar os comandos built-in do shell que s\u00e3o fun\u00e7\u00f5es que s\u00e3o executadas diretamente pelo shell, em vez de serem programas externos. e n\u00e3o exigem a cria\u00e7\u00e3o de um novo processo. Este projeto cont\u00e9m as implementa\u00e7\u00f5es para os comandos exit e env .","title":"builtin.c - Implementa\u00e7\u00e3o de Comandos Built-in"},{"location":"estrutura/#int-index_exitchar-args","text":"Prop\u00f3sito : Implementa o comando exit , que encerra a execu\u00e7\u00e3o do shell. Funcionalidade : Antes de sair, a fun\u00e7\u00e3o chama spinnerLoading() , que exibe uma anima\u00e7\u00e3o de desligamento, proporcionando uma experi\u00eancia de usu\u00e1rio mais agrad\u00e1vel. Ap\u00f3s a anima\u00e7\u00e3o, o shell \u00e9 encerrado com exit(EXIT_SUCCESS) , indicando uma sa\u00edda bem-sucedida.","title":"int index_exit(char **args)"},{"location":"estrutura/#int-index_envchar-args","text":"Prop\u00f3sito : Implementa o comando env , que exibe as vari\u00e1veis de ambiente do processo atual. Funcionalidade : A fun\u00e7\u00e3o acessa a vari\u00e1vel global environ (declarada como extern char **environ; ), que \u00e9 um ponteiro para um array de strings, onde cada string representa uma vari\u00e1vel de ambiente no formato NOME=VALOR . A fun\u00e7\u00e3o itera sobre este array e imprime cada vari\u00e1vel de ambiente em uma nova linha usando a macro p (que envolve printf ).","title":"int index_env(char **args)"},{"location":"estrutura/#int-cell_echochar-args","text":"Prop\u00f3sito : Implementa o comando echo , que imprime os argumentos fornecidos na sa\u00edda padr\u00e3o. Suporta a op\u00e7\u00e3o -n para suprimir a nova linha final. Funcionalidade : A fun\u00e7\u00e3o verifica se o segundo argumento ( args[1] ) \u00e9 \"-n\" . Se for, a flag newline \u00e9 definida como false e o \u00edndice de in\u00edcio para a impress\u00e3o dos argumentos \u00e9 ajustado para 2 (pulando echo e -n ). Caso contr\u00e1rio, a impress\u00e3o come\u00e7a do \u00edndice 1 . A fun\u00e7\u00e3o ent\u00e3o itera sobre os argumentos restantes, imprimindo cada um. Um espa\u00e7o \u00e9 adicionado entre os argumentos. Finalmente, se a flag newline for true , uma nova linha \u00e9 impressa. Este arquivo centraliza a l\u00f3gica para comandos que s\u00e3o parte integrante do shell, garantindo que eles sejam executados de forma eficiente e com o comportamento esperado.","title":"int cell_echo(char **args)"},{"location":"estrutura/#indexc-logica-principal-do-shell-repl","text":"O arquivo index.c cont\u00e9m a l\u00f3gica central do shell, implementando o ciclo REPL (Read-Evaluate-Print/Execute-Loop). Este ciclo \u00e9 o cora\u00e7\u00e3o de qualquer shell interativo, onde o programa l\u00ea a entrada do usu\u00e1rio, a processa, executa o comando correspondente e repete o processo. Al\u00e9m do REPL, index.c gerencia a execu\u00e7\u00e3o de comandos built-in e externos, bem como a divis\u00e3o da linha de comando em argumentos.","title":"index.c - L\u00f3gica Principal do Shell (REPL)"},{"location":"estrutura/#variaveis-globais","text":"int status = 0; : Prop\u00f3sito : Esta vari\u00e1vel global armazena o status de sa\u00edda do \u00faltimo comando executado. \u00c9 um padr\u00e3o comum em shells para que o status de sa\u00edda possa ser consultado por comandos subsequentes ou scripts.","title":"Vari\u00e1veis Globais"},{"location":"estrutura/#funcoes-de-execucao-de-comandos","text":"void index_launch(char **args) : Prop\u00f3sito : Esta fun\u00e7\u00e3o \u00e9 respons\u00e1vel por lan\u00e7ar a execu\u00e7\u00e3o de comandos externos (n\u00e3o built-in). Funcionalidade : Ela utiliza o wrapper Fork() para criar um novo processo filho. Se for o processo filho ( INDEX_jr \u00e9 0, conforme definido em index.h ), ele chama Execvp(args[0], args) para substituir a imagem do processo filho pelo programa especificado em args[0] com seus respectivos argumentos. Se for o processo pai, ele chama Wait(&status) para aguardar a conclus\u00e3o do processo filho e coletar seu status de sa\u00edda, que \u00e9 armazenado na vari\u00e1vel global status . Fluxo de Controle : Esta fun\u00e7\u00e3o \u00e9 crucial para a capacidade do shell de executar programas externos, como ls , grep , etc. void index_exec(char **args) : Prop\u00f3sito : Esta \u00e9 a fun\u00e7\u00e3o principal para a execu\u00e7\u00e3o de comandos, atuando como um despachante para comandos built-in e externos. Funcionalidade : A fun\u00e7\u00e3o itera sobre a estrutura global g_builtin (definida em index.c e populada com os comandos built-in). Para cada entrada em g_builtin , ela compara o nome do comando built-in ( g_builtin[i].builtin_name ) com o primeiro argumento da linha de comando ( args[0] ) usando strcmp . Se uma correspond\u00eancia for encontrada, a fun\u00e7\u00e3o associada ao built-in ( g_builtin[i].foo ) \u00e9 chamada com os argumentos, e o valor de retorno (status de sa\u00edda do built-in) \u00e9 armazenado na vari\u00e1vel global status . Ap\u00f3s a execu\u00e7\u00e3o do built-in, a fun\u00e7\u00e3o retorna. Comandos Built-in : A estrutura g_builtin \u00e9 um array de t_builtin (definido em index.h ), que mapeia nomes de comandos para ponteiros de fun\u00e7\u00e3o. Atualmente, inclui env e exit . A linha comentada {.builtin_name =\"echo\", .foo=index_echo}; sugere que echo foi considerado ou pode ser adicionado no futuro. Execu\u00e7\u00e3o de Comandos Externos : Se nenhum comando built-in corresponder ao args[0] , a fun\u00e7\u00e3o index_launch(args) \u00e9 chamada para tentar executar o comando como um programa externo.","title":"Fun\u00e7\u00f5es de Execu\u00e7\u00e3o de Comandos"},{"location":"estrutura/#funcoes-de-processamento-de-entrada","text":"char **index_split_line(char *line) : Prop\u00f3sito : Esta fun\u00e7\u00e3o \u00e9 respons\u00e1vel por tokenizar a linha de entrada do usu\u00e1rio em argumentos individuais. Funcionalidade : Ela utiliza a fun\u00e7\u00e3o strtok para dividir a string line em tokens, usando os delimitadores definidos pela macro DEL (espa\u00e7o, tabula\u00e7\u00e3o, nova linha, etc.). A fun\u00e7\u00e3o aloca dinamicamente mem\u00f3ria para armazenar os ponteiros para esses tokens. Se a capacidade do buffer for excedida, Realloc \u00e9 usado para dobrar o tamanho do buffer, garantindo que todos os tokens possam ser armazenados. O array de tokens \u00e9 terminado com NULL , o que \u00e9 um padr\u00e3o comum para arrays de strings em C. Gerenciamento de Mem\u00f3ria : A mem\u00f3ria para os tokens \u00e9 alocada usando Malloc e Realloc , garantindo tratamento de erros para falhas de aloca\u00e7\u00e3o. Retorno : Retorna um array de strings ( char ** ) onde cada string \u00e9 um argumento da linha de comando. char *index_read_line(void) : Prop\u00f3sito : Esta fun\u00e7\u00e3o l\u00ea uma linha de entrada do usu\u00e1rio do stdin . Funcionalidade : Ela exibe um prompt para o usu\u00e1rio, que inclui o diret\u00f3rio de trabalho atual (obtido via Getcwd ) e um caractere de shell ( \ud83d\udc1a ). Em seguida, usa getline para ler a linha completa, incluindo espa\u00e7os, at\u00e9 que uma nova linha seja encontrada ou o final do arquivo seja atingido. getline aloca dinamicamente o buffer buf conforme necess\u00e1rio. Tratamento de Erros : Se getline falhar (retornar -1 ), a fun\u00e7\u00e3o libera o buffer alocado e verifica se o final do arquivo ( feof(stdin) ) foi atingido. Se sim, imprime \"[EOF]\" ; caso contr\u00e1rio, imprime \"getline failed\" . Retorno : Retorna um ponteiro para a string lida ou NULL em caso de erro ou final de arquivo.","title":"Fun\u00e7\u00f5es de Processamento de Entrada"},{"location":"estrutura/#funcao-principal-main","text":"int main() : Prop\u00f3sito : A fun\u00e7\u00e3o main \u00e9 o ponto de entrada do programa shell e implementa o loop REPL. Fluxo de Execu\u00e7\u00e3o : Banner : Chama printbanner() para exibir uma mensagem de boas-vindas no in\u00edcio. Loop REPL : Entra em um loop infinito ( while((line = index_read_line())) ) que continua enquanto index_read_line() retornar uma linha v\u00e1lida (ou seja, n\u00e3o NULL ). Leitura (Read) : Dentro do loop, index_read_line() \u00e9 chamada para obter a entrada do usu\u00e1rio, exibindo o prompt e lendo a linha. Avalia\u00e7\u00e3o/Tokeniza\u00e7\u00e3o (Evaluate/Lexing/Parsing) : A linha lida \u00e9 ent\u00e3o passada para index_split_line(line) para ser tokenizada em argumentos. Execu\u00e7\u00e3o (Execute) : Os argumentos tokenizados s\u00e3o passados para index_exec(args) , que decide se o comando \u00e9 um built-in ou um programa externo e o executa. Libera\u00e7\u00e3o de Mem\u00f3ria (Free) : Ap\u00f3s a execu\u00e7\u00e3o do comando, a mem\u00f3ria alocada para a linha ( line ) e os argumentos ( args ) \u00e9 liberada usando free() , prevenindo vazamentos de mem\u00f3ria. Loop (Loop) : O ciclo se repete, solicitando uma nova entrada do usu\u00e1rio. Sa\u00edda : O loop termina quando index_read_line() retorna NULL (indicando EOF ou um erro fatal). O programa ent\u00e3o retorna EXIT_SUCCESS .","title":"Fun\u00e7\u00e3o Principal (main)"},{"location":"estrutura/#estrutura-g_builtin","text":"t_builtin g_builtin[] = { // {.builtin_name =\"echo\", .foo=index_echo}; {.builtin_name =\"env\", .foo=index_env}; {.builtin_name =\"exit\", .foo=index_exit}, {.builtin_name =NULL} }; Prop\u00f3sito : Esta \u00e9 uma vari\u00e1vel global que armazena a lista de comandos built-in que o shell suporta. \u00c9 um array de estruturas t_builtin , onde cada elemento associa o nome de um comando built-in a um ponteiro para a fun\u00e7\u00e3o que o implementa. Extensibilidade : A estrutura \u00e9 terminada com um elemento NULL , permitindo que o shell itere sobre ela para encontrar o comando built-in correto. Novas fun\u00e7\u00f5es built-in podem ser adicionadas a este array para estender a funcionalidade do shell. Em resumo, index.c orquestra o fluxo de trabalho do shell, desde a intera\u00e7\u00e3o com o usu\u00e1rio at\u00e9 a execu\u00e7\u00e3o de comandos, garantindo que o shell funcione como um ambiente de linha de comando interativo e responsivo.","title":"Estrutura g_builtin"},{"location":"estrutura/#conclusao","text":"O projeto de shell em C analisado demonstra uma implementa\u00e7\u00e3o funcional de um interpretador de linha de comando b\u00e1sico. A arquitetura modular, com responsabilidades bem definidas para cada arquivo ( index.h , utils.c , builtin.c , index.c ), contribui para a clareza e manutenibilidade do c\u00f3digo. Os principais recursos implementados incluem: Loop REPL : O shell l\u00ea comandos do usu\u00e1rio, os avalia e os executa, repetindo o ciclo. Execu\u00e7\u00e3o de Comandos Externos : Capacidade de executar programas do sistema operacional atrav\u00e9s de fork e execvp . Comandos Built-in : Implementa\u00e7\u00e3o de comandos internos como exit e env , que s\u00e3o executados diretamente pelo shell para maior efici\u00eancia. Tokeniza\u00e7\u00e3o de Linha de Comando : A entrada do usu\u00e1rio \u00e9 dividida em tokens (comandos e argumentos) para processamento. Gerenciamento de Processos : Utiliza\u00e7\u00e3o de fork , execvp e wait para criar e gerenciar processos filhos. Gerenciamento de Mem\u00f3ria : Uso de malloc e realloc com wrappers para tratamento de erros, garantindo aloca\u00e7\u00e3o e realoca\u00e7\u00e3o de mem\u00f3ria seguras. Interface de Usu\u00e1rio Aprimorada : Uso de cores ANSI para prompts e mensagens, al\u00e9m de um banner de boas-vindas e uma anima\u00e7\u00e3o de desligamento. O c\u00f3digo demonstra boas pr\u00e1ticas de programa\u00e7\u00e3o em C, como o uso de wrappers para chamadas de sistema para centralizar o tratamento de erros e a libera\u00e7\u00e3o de mem\u00f3ria alocada dinamicamente para evitar vazamentos.","title":"Conclus\u00e3o"},{"location":"estrutura/#possiveis-melhorias-e-extensoes","text":"Embora funcional, o shell pode ser estendido com recursos adicionais para torn\u00e1-lo mais robusto e completo, como: Redirecionamento de Entrada/Sa\u00edda : Implementar operadores como > , < , >> e | (pipes). Tratamento de Sinais : Melhorar o tratamento de sinais como SIGINT (Ctrl+C) e SIGTSTP (Ctrl+Z). Vari\u00e1veis de Shell : Permitir a defini\u00e7\u00e3o e o uso de vari\u00e1veis de ambiente locais ao shell. Hist\u00f3rico de Comandos : Implementar um hist\u00f3rico de comandos naveg\u00e1vel. Autocompletar : Adicionar funcionalidade de autocompletar para comandos e nomes de arquivos. Aliases : Permitir a cria\u00e7\u00e3o de aliases para comandos. Jobs em Background : Suporte para executar comandos em segundo plano (usando & ). Scripting : Capacidade de executar scripts de shell.","title":"Poss\u00edveis Melhorias e Extens\u00f5es"},{"location":"estrutura/#limitacoes-conhecidas-da-implementacao","text":"Esta vers\u00e3o do mini-shell possui algumas limita\u00e7\u00f5es: Comandos Built-in Fixos : A lista de comandos built-in ( env , exit , echo ) \u00e9 fixa e n\u00e3o pode ser estendida dinamicamente em tempo de execu\u00e7\u00e3o. Aus\u00eancia de Vari\u00e1veis de Ambiente do Shell : N\u00e3o h\u00e1 suporte para vari\u00e1veis de ambiente internas do shell (ex: $PATH , $HOME ) que podem ser definidas e usadas dentro do shell. Sem Hist\u00f3rico de Comandos : N\u00e3o h\u00e1 funcionalidade de hist\u00f3rico de comandos (setas para cima/baixo). Sem Autocompletar : N\u00e3o h\u00e1 suporte para autocompletar nomes de arquivos ou comandos. Tratamento B\u00e1sico de Erros : Embora perror seja usado para erros de chamadas de sistema, o tratamento de erros para comandos n\u00e3o encontrados \u00e9 gen\u00e9rico (\"Command not found\") e n\u00e3o fornece detalhes espec\u00edficos sobre o motivo da falha (ex: permiss\u00e3o negada, comando inexistente). Aus\u00eancia de Comandos Complexos : N\u00e3o h\u00e1 suporte para estruturas de controle de fluxo (if, for, while), execu\u00e7\u00e3o em segundo plano ( & ), ou encadeamento de comandos com && ou || . Gerenciamento de Jobs : N\u00e3o h\u00e1 suporte para gerenciamento de jobs (suspender, retomar processos).","title":"Limita\u00e7\u00f5es Conhecidas da Implementa\u00e7\u00e3o"},{"location":"mini-Shell/","text":"Como Compilar e Rodar Para compilar o mini-shell, certifique-se de ter o gcc (GNU Compiler Collection) instalado em seu sistema. Em sistemas baseados em Debian/Ubuntu, voc\u00ea pode instal\u00e1-lo com: sudo apt-get update sudo apt-get install build-essential Ap\u00f3s a instala\u00e7\u00e3o do gcc , navegue at\u00e9 o diret\u00f3rio onde os arquivos-fonte ( index.c , utils.c , builtin.c , index.h ) est\u00e3o localizados e execute o seguinte comando para compilar: gcc -o mini_shell index.c utils.c builtin.c -I. Este comando criar\u00e1 um execut\u00e1vel chamado mini_shell no diret\u00f3rio atual. Para rodar o mini-shell, basta executar o bin\u00e1rio: ./mini_shell O shell exibir\u00e1 um prompt interativo ( \ud83d\udc1a/caminho/atual\ud83d\udc1a$> ) onde voc\u00ea poder\u00e1 digitar comandos. V\u00eddeo Curto Demonstrando o Uso do Shell Mini-shell em a\u00e7\u00e3o!","title":"Demonstra\u00e7\u00e3o mini-shell"},{"location":"mini-Shell/#como-compilar-e-rodar","text":"Para compilar o mini-shell, certifique-se de ter o gcc (GNU Compiler Collection) instalado em seu sistema. Em sistemas baseados em Debian/Ubuntu, voc\u00ea pode instal\u00e1-lo com: sudo apt-get update sudo apt-get install build-essential Ap\u00f3s a instala\u00e7\u00e3o do gcc , navegue at\u00e9 o diret\u00f3rio onde os arquivos-fonte ( index.c , utils.c , builtin.c , index.h ) est\u00e3o localizados e execute o seguinte comando para compilar: gcc -o mini_shell index.c utils.c builtin.c -I. Este comando criar\u00e1 um execut\u00e1vel chamado mini_shell no diret\u00f3rio atual. Para rodar o mini-shell, basta executar o bin\u00e1rio: ./mini_shell O shell exibir\u00e1 um prompt interativo ( \ud83d\udc1a/caminho/atual\ud83d\udc1a$> ) onde voc\u00ea poder\u00e1 digitar comandos.","title":"Como Compilar e Rodar"},{"location":"mini-Shell/#video-curto-demonstrando-o-uso-do-shell","text":"Mini-shell em a\u00e7\u00e3o!","title":"V\u00eddeo Curto Demonstrando o Uso do Shell"},{"location":"utils/","text":"Fun\u00e7\u00f5es Utilit\u00e1rias e Wrappers de Chamadas de Sistema utils.c O arquivo utils.c cont\u00e9m uma cole\u00e7\u00e3o de fun\u00e7\u00f5es utilit\u00e1rias e wrappers para chamadas de sistema POSIX. Essas fun\u00e7\u00f5es s\u00e3o projetadas para encapsular a l\u00f3gica de tratamento de erros das chamadas de sistema subjacentes, tornando o c\u00f3digo principal do shell mais limpo e robusto. Em caso de falha, a maioria dessas fun\u00e7\u00f5es imprime uma mensagem de erro usando perror e encerra o programa, garantindo que o shell n\u00e3o continue a operar em um estado inconsistente. Wrappers para Gerenciamento de Processos As fun\u00e7\u00f5es de gerenciamento de processos em utils.c fornecem uma interface segura para opera\u00e7\u00f5es comuns de processos, como cria\u00e7\u00e3o, execu\u00e7\u00e3o e espera: pid_t Fork(void) : Prop\u00f3sito : Este \u00e9 um wrapper para a chamada de sistema fork() . Ele cria um novo processo filho que \u00e9 uma c\u00f3pia exata do processo pai. Comportamento em Erro : Se fork() falhar (retornar um valor negativo), a fun\u00e7\u00e3o imprime uma mensagem de erro ( \"Fork Failed\" ) usando perror e encerra o programa com exit(EX_OSERR) . Isso garante que o shell n\u00e3o tente operar com um processo filho que n\u00e3o foi criado corretamente. Retorno : Retorna o ID do processo filho ( pid_t ) para o processo pai e 0 para o processo filho, conforme o comportamento padr\u00e3o de fork() . void Execvp(const char *file, char *const argv[]) : Prop\u00f3sito : Este wrapper para execvp() substitui a imagem do processo atual por um novo programa. Ele procura o execut\u00e1vel especificado por file nos diret\u00f3rios listados na vari\u00e1vel de ambiente PATH . Comportamento em Erro : Antes de chamar execvp() , a fun\u00e7\u00e3o verifica se file ou argv s\u00e3o nulos. Se forem, imprime uma mensagem de erro no stderr e encerra com exit(EXIT_FAILURE) . Se execvp() falhar (retornar -1 ), imprime uma mensagem de erro ( \"Failed\" ) usando perror e encerra o programa com exit(EX_UNAVAILABLE) . Isso \u00e9 crucial porque execvp() s\u00f3 retorna em caso de erro; um retorno bem-sucedido significa que o novo programa est\u00e1 em execu\u00e7\u00e3o. Argumentos : file \u00e9 o nome do programa a ser executado, e argv \u00e9 um array de strings que representa os argumentos da linha de comando para o novo programa, onde argv[0] \u00e9 o nome do programa. pid_t Wait(int *status) : Prop\u00f3sito : Este wrapper para wait() suspende a execu\u00e7\u00e3o do processo pai at\u00e9 que um de seus processos filhos termine. Ele \u00e9 usado para coletar o status de sa\u00edda de processos filhos e evitar processos zumbis. Comportamento em Erro : A fun\u00e7\u00e3o primeiro verifica se o ponteiro status \u00e9 nulo. Se for, imprime uma mensagem de erro ( \"Wait: status argument required\" ) e retorna -1 . Se wait() falhar (retornar -1 ), imprime uma mensagem de erro ( \"Wait failed\" ) usando perror . Ap\u00f3s a conclus\u00e3o bem-sucedida de wait() , se o processo filho terminou normalmente ( WIFEXITED(*status) ), o status de sa\u00edda real do filho ( WEXITSTATUS(*status) ) \u00e9 armazenado em *status . Retorno : Retorna o ID do processo filho que terminou ou -1 em caso de erro. Wrappers para Gerenciamento de Mem\u00f3ria As fun\u00e7\u00f5es de gerenciamento de mem\u00f3ria em utils.c fornecem aloca\u00e7\u00e3o e realoca\u00e7\u00e3o de mem\u00f3ria seguras, com tratamento de erros integrado: void *Malloc(size_t size) : Prop\u00f3sito : Este wrapper para malloc() aloca um bloco de mem\u00f3ria do tamanho especificado. Comportamento em Erro : Se malloc() falhar (retornar NULL ), a fun\u00e7\u00e3o imprime uma mensagem de erro ( \"Malloc Failed\" ) usando perror e encerra o programa com exit(EXIT_FAILURE) . Um caso especial \u00e9 quando size \u00e9 0 , para o qual Malloc retorna NULL sem erro, seguindo o comportamento comum de malloc para aloca\u00e7\u00f5es de tamanho zero. Retorno : Retorna um ponteiro para o bloco de mem\u00f3ria alocado ou NULL se size for 0 . void *Realloc(void *ptr, size_t size) : Prop\u00f3sito : Este wrapper para realloc() redimensiona o bloco de mem\u00f3ria apontado por ptr para o novo size . Comportamento em Erro : Se realloc() falhar (retornar NULL ) e o size n\u00e3o for 0 , a fun\u00e7\u00e3o imprime uma mensagem de erro ( \"Realloc Failed\" ) usando perror e encerra o programa com exit(EXIT_FAILURE) . Se size for 0 , realloc se comporta como free(ptr) , e a fun\u00e7\u00e3o retorna NULL sem erro, o que \u00e9 um comportamento v\u00e1lido. Retorno : Retorna um ponteiro para o bloco de mem\u00f3ria redimensionado ou NULL se a realoca\u00e7\u00e3o falhar ou se size for 0 . Wrappers para Opera\u00e7\u00f5es de Diret\u00f3rio utils.c inclui um wrapper para obter o diret\u00f3rio de trabalho atual: void Getcwd(char *buf, size_t size) : Prop\u00f3sito : Este wrapper para getcwd() copia o caminho absoluto do diret\u00f3rio de trabalho atual para o buffer buf . Comportamento em Erro : Se getcwd() falhar (retornar NULL ), a fun\u00e7\u00e3o imprime uma mensagem de erro ( \"getcwd FAILED\" ) usando perror . Argumentos : buf \u00e9 o buffer onde o caminho ser\u00e1 armazenado, e size \u00e9 o tamanho m\u00e1ximo do buffer. Fun\u00e7\u00f5es de Interface do Usu\u00e1rio Al\u00e9m dos wrappers, utils.c tamb\u00e9m cont\u00e9m fun\u00e7\u00f5es para melhorar a experi\u00eancia do usu\u00e1rio com elementos visuais: void printbanner(void) : Prop\u00f3sito : Imprime um banner ASCII art no console. Este banner \u00e9 exibido no in\u00edcio do shell, fornecendo uma sauda\u00e7\u00e3o visual. Implementa\u00e7\u00e3o : Utiliza a macro p (que envolve printf ) e c\u00f3digos de cores ANSI (definidos em index.h ) para exibir o banner com formata\u00e7\u00e3o colorida. void spinnerLoading() : Prop\u00f3sito : Exibe uma anima\u00e7\u00e3o de \"carregamento\" ou \"desligamento\" no console, simulando um processo em andamento antes de o shell ser encerrado. Implementa\u00e7\u00e3o : A fun\u00e7\u00e3o usa um array de strings ( charging[] ) para representar os diferentes quadros da anima\u00e7\u00e3o de um spinner. Ela itera sobre esses quadros, imprimindo cada um com um atraso ( usleep ) e for\u00e7ando a atualiza\u00e7\u00e3o do console ( fflush(stdout) ). No final da anima\u00e7\u00e3o, imprime uma mensagem de sa\u00edda e encerra o programa com exit(X_OK) (onde X_OK \u00e9 uma constante definida em index.h como EX_OK ). Em resumo, utils.c \u00e9 um componente vital do shell, fornecendo uma camada de abstra\u00e7\u00e3o e tratamento de erros para opera\u00e7\u00f5es de baixo n\u00edvel, o que contribui significativamente para a robustez e a confiabilidade do sistema.","title":"Fun\u00e7\u00f5es Utilit\u00e1rias e Wrappers de Chamadas de Sistema"},{"location":"utils/#funcoes-utilitarias-e-wrappers-de-chamadas-de-sistema","text":"","title":"Fun\u00e7\u00f5es Utilit\u00e1rias e Wrappers de Chamadas de Sistema"},{"location":"utils/#utilsc","text":"O arquivo utils.c cont\u00e9m uma cole\u00e7\u00e3o de fun\u00e7\u00f5es utilit\u00e1rias e wrappers para chamadas de sistema POSIX. Essas fun\u00e7\u00f5es s\u00e3o projetadas para encapsular a l\u00f3gica de tratamento de erros das chamadas de sistema subjacentes, tornando o c\u00f3digo principal do shell mais limpo e robusto. Em caso de falha, a maioria dessas fun\u00e7\u00f5es imprime uma mensagem de erro usando perror e encerra o programa, garantindo que o shell n\u00e3o continue a operar em um estado inconsistente.","title":"utils.c"},{"location":"utils/#wrappers-para-gerenciamento-de-processos","text":"As fun\u00e7\u00f5es de gerenciamento de processos em utils.c fornecem uma interface segura para opera\u00e7\u00f5es comuns de processos, como cria\u00e7\u00e3o, execu\u00e7\u00e3o e espera: pid_t Fork(void) : Prop\u00f3sito : Este \u00e9 um wrapper para a chamada de sistema fork() . Ele cria um novo processo filho que \u00e9 uma c\u00f3pia exata do processo pai. Comportamento em Erro : Se fork() falhar (retornar um valor negativo), a fun\u00e7\u00e3o imprime uma mensagem de erro ( \"Fork Failed\" ) usando perror e encerra o programa com exit(EX_OSERR) . Isso garante que o shell n\u00e3o tente operar com um processo filho que n\u00e3o foi criado corretamente. Retorno : Retorna o ID do processo filho ( pid_t ) para o processo pai e 0 para o processo filho, conforme o comportamento padr\u00e3o de fork() . void Execvp(const char *file, char *const argv[]) : Prop\u00f3sito : Este wrapper para execvp() substitui a imagem do processo atual por um novo programa. Ele procura o execut\u00e1vel especificado por file nos diret\u00f3rios listados na vari\u00e1vel de ambiente PATH . Comportamento em Erro : Antes de chamar execvp() , a fun\u00e7\u00e3o verifica se file ou argv s\u00e3o nulos. Se forem, imprime uma mensagem de erro no stderr e encerra com exit(EXIT_FAILURE) . Se execvp() falhar (retornar -1 ), imprime uma mensagem de erro ( \"Failed\" ) usando perror e encerra o programa com exit(EX_UNAVAILABLE) . Isso \u00e9 crucial porque execvp() s\u00f3 retorna em caso de erro; um retorno bem-sucedido significa que o novo programa est\u00e1 em execu\u00e7\u00e3o. Argumentos : file \u00e9 o nome do programa a ser executado, e argv \u00e9 um array de strings que representa os argumentos da linha de comando para o novo programa, onde argv[0] \u00e9 o nome do programa. pid_t Wait(int *status) : Prop\u00f3sito : Este wrapper para wait() suspende a execu\u00e7\u00e3o do processo pai at\u00e9 que um de seus processos filhos termine. Ele \u00e9 usado para coletar o status de sa\u00edda de processos filhos e evitar processos zumbis. Comportamento em Erro : A fun\u00e7\u00e3o primeiro verifica se o ponteiro status \u00e9 nulo. Se for, imprime uma mensagem de erro ( \"Wait: status argument required\" ) e retorna -1 . Se wait() falhar (retornar -1 ), imprime uma mensagem de erro ( \"Wait failed\" ) usando perror . Ap\u00f3s a conclus\u00e3o bem-sucedida de wait() , se o processo filho terminou normalmente ( WIFEXITED(*status) ), o status de sa\u00edda real do filho ( WEXITSTATUS(*status) ) \u00e9 armazenado em *status . Retorno : Retorna o ID do processo filho que terminou ou -1 em caso de erro.","title":"Wrappers para Gerenciamento de Processos"},{"location":"utils/#wrappers-para-gerenciamento-de-memoria","text":"As fun\u00e7\u00f5es de gerenciamento de mem\u00f3ria em utils.c fornecem aloca\u00e7\u00e3o e realoca\u00e7\u00e3o de mem\u00f3ria seguras, com tratamento de erros integrado: void *Malloc(size_t size) : Prop\u00f3sito : Este wrapper para malloc() aloca um bloco de mem\u00f3ria do tamanho especificado. Comportamento em Erro : Se malloc() falhar (retornar NULL ), a fun\u00e7\u00e3o imprime uma mensagem de erro ( \"Malloc Failed\" ) usando perror e encerra o programa com exit(EXIT_FAILURE) . Um caso especial \u00e9 quando size \u00e9 0 , para o qual Malloc retorna NULL sem erro, seguindo o comportamento comum de malloc para aloca\u00e7\u00f5es de tamanho zero. Retorno : Retorna um ponteiro para o bloco de mem\u00f3ria alocado ou NULL se size for 0 . void *Realloc(void *ptr, size_t size) : Prop\u00f3sito : Este wrapper para realloc() redimensiona o bloco de mem\u00f3ria apontado por ptr para o novo size . Comportamento em Erro : Se realloc() falhar (retornar NULL ) e o size n\u00e3o for 0 , a fun\u00e7\u00e3o imprime uma mensagem de erro ( \"Realloc Failed\" ) usando perror e encerra o programa com exit(EXIT_FAILURE) . Se size for 0 , realloc se comporta como free(ptr) , e a fun\u00e7\u00e3o retorna NULL sem erro, o que \u00e9 um comportamento v\u00e1lido. Retorno : Retorna um ponteiro para o bloco de mem\u00f3ria redimensionado ou NULL se a realoca\u00e7\u00e3o falhar ou se size for 0 .","title":"Wrappers para Gerenciamento de Mem\u00f3ria"},{"location":"utils/#wrappers-para-operacoes-de-diretorio","text":"utils.c inclui um wrapper para obter o diret\u00f3rio de trabalho atual: void Getcwd(char *buf, size_t size) : Prop\u00f3sito : Este wrapper para getcwd() copia o caminho absoluto do diret\u00f3rio de trabalho atual para o buffer buf . Comportamento em Erro : Se getcwd() falhar (retornar NULL ), a fun\u00e7\u00e3o imprime uma mensagem de erro ( \"getcwd FAILED\" ) usando perror . Argumentos : buf \u00e9 o buffer onde o caminho ser\u00e1 armazenado, e size \u00e9 o tamanho m\u00e1ximo do buffer.","title":"Wrappers para Opera\u00e7\u00f5es de Diret\u00f3rio"},{"location":"utils/#funcoes-de-interface-do-usuario","text":"Al\u00e9m dos wrappers, utils.c tamb\u00e9m cont\u00e9m fun\u00e7\u00f5es para melhorar a experi\u00eancia do usu\u00e1rio com elementos visuais: void printbanner(void) : Prop\u00f3sito : Imprime um banner ASCII art no console. Este banner \u00e9 exibido no in\u00edcio do shell, fornecendo uma sauda\u00e7\u00e3o visual. Implementa\u00e7\u00e3o : Utiliza a macro p (que envolve printf ) e c\u00f3digos de cores ANSI (definidos em index.h ) para exibir o banner com formata\u00e7\u00e3o colorida. void spinnerLoading() : Prop\u00f3sito : Exibe uma anima\u00e7\u00e3o de \"carregamento\" ou \"desligamento\" no console, simulando um processo em andamento antes de o shell ser encerrado. Implementa\u00e7\u00e3o : A fun\u00e7\u00e3o usa um array de strings ( charging[] ) para representar os diferentes quadros da anima\u00e7\u00e3o de um spinner. Ela itera sobre esses quadros, imprimindo cada um com um atraso ( usleep ) e for\u00e7ando a atualiza\u00e7\u00e3o do console ( fflush(stdout) ). No final da anima\u00e7\u00e3o, imprime uma mensagem de sa\u00edda e encerra o programa com exit(X_OK) (onde X_OK \u00e9 uma constante definida em index.h como EX_OK ). Em resumo, utils.c \u00e9 um componente vital do shell, fornecendo uma camada de abstra\u00e7\u00e3o e tratamento de erros para opera\u00e7\u00f5es de baixo n\u00edvel, o que contribui significativamente para a robustez e a confiabilidade do sistema.","title":"Fun\u00e7\u00f5es de Interface do Usu\u00e1rio"}]}