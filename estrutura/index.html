<!DOCTYPE html>
<html lang="en" data-bs-theme="auto">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        
        <link rel="shortcut icon" href="../img/favicon.ico">
        <title>Explicação da Estrutura - SO</title>
        <link href="../css/bootstrap.min.css" rel="stylesheet">
        <link href="../css/fontawesome.min.css" rel="stylesheet">
        <link href="../css/brands.min.css" rel="stylesheet">
        <link href="../css/solid.min.css" rel="stylesheet">
        <link href="../css/v4-font-face.min.css" rel="stylesheet">
        <link href="../css/base.css" rel="stylesheet">
        <link id="hljs-light" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" disabled>
        <link id="hljs-dark" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github-dark.min.css" disabled>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
        <script>hljs.highlightAll();</script> 
    </head>

    <body>
        <div class="navbar fixed-top navbar-expand-lg navbar-dark bg-primary">
            <div class="container">
                <a class="navbar-brand" href="..">SO</a>
                <!-- Expander button -->
                <button type="button" class="navbar-toggler" data-bs-toggle="collapse" data-bs-target="#navbar-collapse" aria-controls="navbar-collapse" aria-expanded="false" aria-label="Toggle navigation">
                    <span class="navbar-toggler-icon"></span>
                </button>

                <!-- Expanded navigation -->
                <div id="navbar-collapse" class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li class="nav-item">
                                <a href=".." class="nav-link">Introdução</a>
                            </li>
                            <li class="nav-item">
                                <a href="./" class="nav-link active" aria-current="page">Explicação da Estrutura</a>
                            </li>
                            <li class="nav-item">
                                <a href="../chamadas/" class="nav-link">Chamadas ao Sistema</a>
                            </li>
                            <li class="nav-item">
                                <a href="../mini-Shell/" class="nav-link">Demonstração mini-shell</a>
                            </li>
                            <li class="nav-item">
                                <a href="../casos%20de%20uso/" class="nav-link">Casos de uso</a>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav ms-md-auto">
                        <li class="nav-item">
                            <a href="#" class="nav-link" data-bs-toggle="modal" data-bs-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                            <li class="nav-item">
                                <a rel="prev" href=".." class="nav-link">
                                    <i class="fa fa-arrow-left"></i> Previous
                                </a>
                            </li>
                            <li class="nav-item">
                                <a rel="next" href="../chamadas/" class="nav-link">
                                    Next <i class="fa fa-arrow-right"></i>
                                </a>
                            </li>
                            <li class="nav-item">
                                <a href="https://github.com/carolbalbs/-SO-mini-shell/edit/master/docs/estrutura.md" class="nav-link"><i class="fa-brands fa-github"></i> Edit on GitHub</a>
                            </li>
                            <li class="nav-item dropdown">
                              <button id="theme-menu" aria-expanded="false" data-bs-toggle="dropdown" data-bs-display="static" aria-label="Toggle theme" class="nav-link dropdown-toggle">
                                <i class="fa-solid fa-circle-half-stroke fa-fw"></i>
                                <span class="d-lg-none ms-2">Toggle theme</span>
                              </button>
                              <ul class="dropdown-menu dropdown-menu-end">
                                <li>
                                  <button class="dropdown-item d-flex align-items-center" data-bs-theme-value="light" aria-pressed="false">
                                    <i class="fa-solid fa-sun fa-fw"></i>
                                    <span class="ms-2">Light</span>
                                    <i class="fa-solid fa-check ms-auto d-none"></i>
                                  </button>
                                </li>
                                <li>
                                  <button class="dropdown-item d-flex align-items-center" data-bs-theme-value="dark" aria-pressed="false">
                                    <i class="fa-solid fa-moon fa-fw"></i>
                                    <span class="ms-2">Dark</span>
                                    <i class="fa-solid fa-check ms-auto d-none"></i>
                                  </button>
                                </li>
                                <li>
                                  <button class="dropdown-item d-flex align-items-center" data-bs-theme-value="auto" aria-pressed="true">
                                    <i class="fa-solid fa-circle-half-stroke fa-fw"></i>
                                    <span class="ms-2">Auto</span>
                                    <i class="fa-solid fa-check ms-auto"></i>
                                  </button>
                                </li>
                              </ul>
                            </li>
                    </ul>
                </div>
            </div>
        </div>
        <script src="../js/darkmode.js"></script>

        <div class="container">
            <div class="row">
                    <div class="col-md-3"><div class="navbar-expand-md bs-sidebar hidden-print affix" role="complementary">
    <div class="navbar-header">
        <button type="button" class="navbar-toggler collapsed" data-bs-toggle="collapse" data-bs-target="#toc-collapse" title="Table of Contents">
            <span class="fa fa-angle-down"></span>
        </button>
    </div>

    
    <div id="toc-collapse" class="navbar-collapse collapse card bg-body-tertiary">
        <ul class="nav flex-column">
            
            <li class="nav-item" data-bs-level="1"><a href="#logica-principal-do-shell" class="nav-link">Lógica Principal do Shell</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-bs-level="2"><a href="#introducao" class="nav-link">Introdução</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#indexh-arquivo-de-cabecalho-principal" class="nav-link">index.h - Arquivo de Cabeçalho Principal</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#utilsc-funcoes-utilitarias-e-wrappers-de-chamadas-de-sistema" class="nav-link">utils.c - Funções Utilitárias e Wrappers de Chamadas de Sistema</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#builtinc-implementacao-de-comandos-built-in" class="nav-link">builtin.c - Implementação de Comandos Built-in</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#indexc-logica-principal-do-shell-repl" class="nav-link">index.c - Lógica Principal do Shell (REPL)</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#conclusao" class="nav-link">Conclusão</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#limitacoes-conhecidas-da-implementacao" class="nav-link">Limitações Conhecidas da Implementação</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
        </ul>
    </div>
</div></div>
                    <div class="col-md-9" role="main">

<h1 id="logica-principal-do-shell">Lógica Principal do Shell</h1>
<h2 id="introducao">Introdução</h2>
<p>Os arquivos de código-fonte C que compõem a implementação de um shell básico.</p>
<p>O projeto é dividido em módulos, cada um com responsabilidades específicas:</p>
<ul>
<li><code>index.h</code>: Arquivo de cabeçalho que contém definições globais, macros e protótipos de funções.</li>
<li><code>utils.c</code>: Implementa funções utilitárias e wrappers para chamadas de sistema.</li>
<li><code>builtin.c</code>: Contém a implementação de comandos built-in do shell.</li>
<li><code>index.c</code>: A lógica principal do shell, incluindo o loop de leitura, avaliação e execução de comandos (REPL).</li>
</ul>
<h2 id="indexh-arquivo-de-cabecalho-principal"><code>index.h</code> - Arquivo de Cabeçalho Principal</h2>
<p>O arquivo <code>index.h</code> serve como o cabeçalho central para o projeto do shell, definindo constantes, incluindo bibliotecas padrão, declarando macros e protótipos de funções que são utilizadas em múltiplos arquivos-fonte. Ele estabelece a base para a comunicação e a coerência entre os diferentes módulos do shell.</p>
<h3 id="constantes-e-codigos-de-saida">Constantes e Códigos de Saída</h3>
<p>Este cabeçalho define códigos de saída padrão que são utilizados em todo o projeto para indicar o status de sucesso ou falha de operações. Estes incluem:</p>
<ul>
<li><code>EX_OK</code>: Representa uma saída bem-sucedida, geralmente associada a <code>EXIT_SUCCESS</code>.</li>
<li><code>EX_OSERR</code>: Indica um erro de sistema operacional, como falha na criação de um processo (<code>fork</code>).</li>
<li><code>EX_UNAVAILABLE</code>: Sinaliza que um comando ou serviço não está disponível, como uma falha na execução de um programa (<code>execvp</code>).</li>
</ul>
<h3 id="inclusoes-de-bibliotecas-padrao">Inclusões de Bibliotecas Padrão</h3>
<p>Para garantir a funcionalidade completa do shell, <code>index.h</code> inclui várias bibliotecas padrão do C, que fornecem acesso a funções essenciais para manipulação de entrada/saída, gerenciamento de memória, operações de string e controle de processos:</p>
<ul>
<li><code>&lt;stdio.h&gt;</code>: Para funções de entrada e saída, como <code>printf</code> e <code>getline</code>.</li>
<li><code>&lt;stdlib.h&gt;</code>: Para funções de uso geral, como alocação de memória (<code>malloc</code>, <code>realloc</code>, <code>free</code>) e controle de processos (<code>exit</code>).</li>
<li><code>&lt;unistd.h&gt;</code>: Para acesso a chamadas de sistema POSIX, como <code>fork</code>, <code>execvp</code> e <code>getcwd</code>.</li>
<li><code>&lt;string.h&gt;</code>: Para funções de manipulação de strings, como <code>strcmp</code> e <code>strtok</code>.</li>
<li><code>&lt;sys/wait.h&gt;</code>: Para funções relacionadas ao controle de processos filhos, como <code>wait</code> e macros para verificar o status de saída de processos (<code>WIFEXITED</code>, <code>WEXITSTATUS</code>).</li>
</ul>
<h3 id="utilitarios">Utilitários</h3>
<p>O arquivo <code>index.h</code> define macros que simplificam a formatação da saída do terminal com cores ANSI e facilitam a impressão de mensagens. Essas macros são cruciais para melhorar a legibilidade e a experiência do usuário no shell:</p>
<ul>
<li><strong>Cores ANSI</strong>: Macros como <code>Y</code> (Amarelo), <code>G</code> (Verde), <code>C</code> (Ciano), <code>RED</code> (Vermelho) e <code>RST</code> (Reset) são definidas para aplicar cores ao texto no terminal, tornando as mensagens de status e prompts mais visuais.</li>
</ul>
<h3 id="prototipos-de-funcoes">Protótipos de Funções</h3>
<p><code>index.h</code> declara os protótipos de todas as funções públicas que são implementadas nos arquivos <code>.c</code> do projeto. Isso garante que as funções possam ser chamadas de outros arquivos sem problemas de compilação. As funções prototipadas incluem:</p>
<ul>
<li><code>printbanner(void)</code>: Imprime um banner de boas-vindas no início do shell.</li>
<li><code>spinnerLoading()</code>: Exibe uma animação de carregamento, geralmente usada antes de sair do shell.</li>
<li><code>Chdir(const char *path)</code>: Wrapper para a função <code>chdir</code> (não implementada nos arquivos fornecidos, mas prototipada).</li>
<li><code>Fork(void)</code>: Wrapper para a função <code>fork</code>, para criar um novo processo.</li>
<li><code>Execvp(const char *file, char *const argv[])</code>: Wrapper para a função <code>execvp</code>, para executar um programa.</li>
<li><code>Wait(int *status)</code>: Wrapper para a função <code>wait</code>, para aguardar a conclusão de um processo filho.</li>
<li><code>Wait(pid_t pid, int *status, int options)</code>: Uma sobrecarga ou declaração duplicada de <code>Wait</code>, que pode indicar uma intenção de ter uma função <code>waitpid</code> ou um erro de prototipagem.</li>
<li><code>index_exit(char **)</code>: Implementação do comando built-in <code>exit</code>.</li>
<li><code>Getcwd(char *, size_t)</code>: Wrapper para a função <code>getcwd</code>, para obter o diretório de trabalho atual.</li>
<li><code>Malloc(size_t)</code>: Wrapper para a função <code>malloc</code>, para alocação de memória.</li>
<li><code>Realloc(void *ptr, size_t size)</code>: Wrapper para a função <code>realloc</code>, para realocação de memória.</li>
</ul>
<p>Em resumo, <code>index.h</code> é o ponto de partida para entender a estrutura e as dependências do projeto do shell, fornecendo as definições e declarações necessárias para que os diferentes componentes funcionem em conjunto.</p>
<h2 id="utilsc-funcoes-utilitarias-e-wrappers-de-chamadas-de-sistema"><code>utils.c</code> - Funções Utilitárias e Wrappers de Chamadas de Sistema</h2>
<p>O arquivo <code>utils.c</code> contém uma coleção de funções utilitárias e wrappers para chamadas de sistema POSIX. funções são projetadas para encapsular a lógica de tratamento de erros das chamadas de sistema subjacentes, tornando o código principal do shell mais limpo e robusto. Em caso de falha, a maioria dessas funções imprime uma mensagem de erro usando <code>perror</code> e encerra o programa, garantindo que o shell não continue a operar em um estado inconsistente.</p>
<h3 id="wrappers-para-gerenciamento-de-processos">Wrappers para Gerenciamento de Processos</h3>
<p>As funções de gerenciamento de processos em <code>utils.c</code> fornecem uma interface segura para operações comuns de processos, como criação, execução e espera:</p>
<ul>
<li>
<p><code>pid_t Fork(void)</code>:</p>
<ul>
<li><strong>Propósito</strong>: Este é um wrapper para a chamada de sistema <code>fork()</code>. Ele cria um novo processo filho que é uma cópia exata do processo pai.</li>
<li><strong>Comportamento em Erro</strong>: Se <code>fork()</code> falhar (retornar um valor negativo), a função imprime uma mensagem de erro (<code>"Fork Failed"</code>) usando <code>perror</code> e encerra o programa com <code>exit(EX_OSERR)</code>. Isso garante que o shell não tente operar com um processo filho que não foi criado corretamente.</li>
<li><strong>Retorno</strong>: Retorna o ID do processo filho (<code>pid_t</code>) para o processo pai e <code>0</code> para o processo filho, conforme o comportamento padrão de <code>fork()</code>.</li>
</ul>
</li>
<li>
<p><code>void Execvp(const char *file, char *const argv[])</code>:</p>
<ul>
<li><strong>Propósito</strong>: Este wrapper para <code>execvp()</code> substitui a imagem do processo atual por um novo programa. Ele procura o executável especificado por <code>file</code> nos diretórios listados na variável de ambiente <code>PATH</code>.</li>
<li><strong>Comportamento em Erro</strong>: Antes de chamar <code>execvp()</code>, a função verifica se <code>file</code> ou <code>argv</code> são nulos. Se forem, imprime uma mensagem de erro no <code>stderr</code> e encerra com <code>exit(EXIT_FAILURE)</code>. Se <code>execvp()</code> falhar (retornar <code>-1</code>), imprime uma mensagem de erro (<code>"Failed"</code>) usando <code>perror</code> e encerra o programa com <code>exit(EX_UNAVAILABLE)</code>. Isso é crucial porque <code>execvp()</code> só retorna em caso de erro; um retorno bem-sucedido significa que o novo programa está em execução.</li>
<li><strong>Argumentos</strong>: <code>file</code> é o nome do programa a ser executado, e <code>argv</code> é um array de strings que representa os argumentos da linha de comando para o novo programa, onde <code>argv[0]</code> é o nome do programa.</li>
</ul>
</li>
<li>
<p><code>pid_t Wait(int *status)</code>:</p>
<ul>
<li><strong>Propósito</strong>: Este wrapper para <code>wait()</code> suspende a execução do processo pai até que um de seus processos filhos termine. Ele é usado para coletar o status de saída de processos filhos e evitar processos zumbis.</li>
<li><strong>Comportamento em Erro</strong>: A função primeiro verifica se o ponteiro <code>status</code> é nulo. Se for, imprime uma mensagem de erro (<code>"Wait: status argument required"</code>) e retorna <code>-1</code>. Se <code>wait()</code> falhar (retornar <code>-1</code>), imprime uma mensagem de erro (<code>"Wait failed"</code>) usando <code>perror</code>. Após a conclusão bem-sucedida de <code>wait()</code>, se o processo filho terminou normalmente (<code>WIFEXITED(*status)</code>), o status de saída real do filho (<code>WEXITSTATUS(*status)</code>) é armazenado em <code>*status</code>.</li>
<li><strong>Retorno</strong>: Retorna o ID do processo filho que terminou ou <code>-1</code> em caso de erro.</li>
</ul>
</li>
</ul>
<h3 id="wrappers-para-gerenciamento-de-memoria">Wrappers para Gerenciamento de Memória</h3>
<p>As funções de gerenciamento de memória em <code>utils.c</code> fornecem alocação e realocação de memória seguras, com tratamento de erros integrado:</p>
<ul>
<li>
<p><code>void *Malloc(size_t size)</code>:</p>
<ul>
<li><strong>Propósito</strong>: Este wrapper para <code>malloc()</code> aloca um bloco de memória do tamanho especificado.</li>
<li><strong>Comportamento em Erro</strong>: Se <code>malloc()</code> falhar (retornar <code>NULL</code>), a função imprime uma mensagem de erro (<code>"Malloc Failed"</code>) usando <code>perror</code> e encerra o programa com <code>exit(EXIT_FAILURE)</code>. Um caso especial é quando <code>size</code> é <code>0</code>, para o qual <code>Malloc</code> retorna <code>NULL</code> sem erro, seguindo o comportamento comum de <code>malloc</code> para alocações de tamanho zero.</li>
<li><strong>Retorno</strong>: Retorna um ponteiro para o bloco de memória alocado ou <code>NULL</code> se <code>size</code> for <code>0</code>.</li>
</ul>
</li>
<li>
<p><code>void *Realloc(void *ptr, size_t size)</code>:</p>
<ul>
<li><strong>Propósito</strong>: Este wrapper para <code>realloc()</code> redimensiona o bloco de memória apontado por <code>ptr</code> para o novo <code>size</code>.</li>
<li><strong>Comportamento em Erro</strong>: Se <code>realloc()</code> falhar (retornar <code>NULL</code>) e o <code>size</code> não for <code>0</code>, a função imprime uma mensagem de erro (<code>"Realloc Failed"</code>) usando <code>perror</code> e encerra o programa com <code>exit(EXIT_FAILURE)</code>. Se <code>size</code> for <code>0</code>, <code>realloc</code> se comporta como <code>free(ptr)</code>, e a função retorna <code>NULL</code> sem erro, o que é um comportamento válido.</li>
<li><strong>Retorno</strong>: Retorna um ponteiro para o bloco de memória redimensionado ou <code>NULL</code> se a realocação falhar ou se <code>size</code> for <code>0</code>.</li>
</ul>
</li>
</ul>
<h3 id="wrappers-para-operacoes-de-diretorio">Wrappers para Operações de Diretório</h3>
<p><code>utils.c</code> inclui um wrapper para obter o diretório de trabalho atual:</p>
<ul>
<li><code>void Getcwd(char *buf, size_t size)</code>:<ul>
<li><strong>Propósito</strong>: Este wrapper para <code>getcwd()</code> copia o caminho absoluto do diretório de trabalho atual para o buffer <code>buf</code>.</li>
<li><strong>Comportamento em Erro</strong>: Se <code>getcwd()</code> falhar (retornar <code>NULL</code>), a função imprime uma mensagem de erro (<code>"getcwd FAILED"</code>) usando <code>perror</code>.</li>
<li><strong>Argumentos</strong>: <code>buf</code> é o buffer onde o caminho será armazenado, e <code>size</code> é o tamanho máximo do buffer.</li>
</ul>
</li>
</ul>
<h3 id="funcoes-de-interface-do-usuario">Funções de Interface do Usuário</h3>
<p>Além dos wrappers, <code>utils.c</code> também contém funções para melhorar a experiência do usuário com elementos visuais:</p>
<ul>
<li>
<p><code>void printbanner(void)</code>:</p>
<ul>
<li><strong>Propósito</strong>: Imprime um banner ASCII art no console. Este banner é exibido no início do shell, fornecendo uma saudação visual.</li>
<li><strong>Implementação</strong>: Utiliza a macro <code>p</code> (que envolve <code>printf</code>) e códigos de cores ANSI (definidos em <code>index.h</code>) para exibir o banner com formatação colorida.</li>
</ul>
</li>
<li>
<p><code>void spinnerLoading()</code>:</p>
<ul>
<li><strong>Propósito</strong>: Exibe uma animação de "carregamento" ou "desligamento" no console, simulando um processo em andamento antes de o shell ser encerrado.</li>
<li><strong>Implementação</strong>: A função usa um array de strings (<code>charging[]</code>) para representar os diferentes quadros da animação de um spinner. Ela itera sobre esses quadros, imprimindo cada um com um atraso (<code>usleep</code>) e forçando a atualização do console (<code>fflush(stdout)</code>). No final da animação, imprime uma mensagem de saída e encerra o programa com <code>exit(X_OK)</code> (onde <code>X_OK</code> é uma constante definida em <code>index.h</code> como <code>EX_OK</code>).</li>
</ul>
</li>
</ul>
<p>Em resumo, <code>utils.c</code> é um componente vital do shell, fornecendo uma camada de abstração e tratamento de erros para operações de baixo nível, o que contribui significativamente para a robustez e a confiabilidade do sistema.</p>
<h2 id="builtinc-implementacao-de-comandos-built-in"><code>builtin.c</code> - Implementação de Comandos Built-in</h2>
<p>O arquivo <code>builtin.c</code> é responsável por implementar os comandos built-in do shell que são funções que são executadas diretamente pelo shell, em vez de serem programas externos. e não exigem a criação de um novo processo.   Este projeto contém as implementações para os comandos <code>exit</code> e <code>env</code>.</p>
<h3 id="int-index_exitchar-args"><code>int index_exit(char **args)</code></h3>
<ul>
<li><strong>Propósito</strong>: Implementa o comando <code>exit</code>, que encerra a execução do shell.</li>
<li><strong>Funcionalidade</strong>: Antes de sair, a função chama <code>spinnerLoading()</code>, que exibe uma animação de desligamento, proporcionando uma experiência de usuário mais agradável. Após a animação, o shell é encerrado com <code>exit(EXIT_SUCCESS)</code>, indicando uma saída bem-sucedida.</li>
</ul>
<h3 id="int-index_envchar-args"><code>int index_env(char **args)</code></h3>
<ul>
<li><strong>Propósito</strong>: Implementa o comando <code>env</code>, que exibe as variáveis de ambiente do processo atual.</li>
<li><strong>Funcionalidade</strong>: A função acessa a variável global <code>environ</code> (declarada como <code>extern char **environ;</code>), que é um ponteiro para um array de strings, onde cada string representa uma variável de ambiente no formato <code>NOME=VALOR</code>. A função itera sobre este array e imprime cada variável de ambiente em uma nova linha usando a macro <code>p</code> (que envolve <code>printf</code>).</li>
</ul>
<h3 id="int-cell_echochar-args"><code>int cell_echo(char **args)</code></h3>
<ul>
<li><strong>Propósito</strong>: Implementa o comando <code>echo</code>, que imprime os argumentos fornecidos na saída padrão. Suporta a opção <code>-n</code> para suprimir a nova linha final.</li>
<li><strong>Funcionalidade</strong>: A função verifica se o segundo argumento (<code>args[1]</code>) é <code>"-n"</code>. Se for, a flag <code>newline</code> é definida como <code>false</code> e o índice de início para a impressão dos argumentos é ajustado para <code>2</code> (pulando <code>echo</code> e <code>-n</code>). Caso contrário, a impressão começa do índice <code>1</code>. A função então itera sobre os argumentos restantes, imprimindo cada um. Um espaço é adicionado entre os argumentos. Finalmente, se a flag <code>newline</code> for <code>true</code>, uma nova linha é impressa.</li>
</ul>
<p>Este arquivo centraliza a lógica para comandos que são parte integrante do shell, garantindo que eles sejam executados de forma eficiente e com o comportamento esperado.</p>
<h2 id="indexc-logica-principal-do-shell-repl"><code>index.c</code> - Lógica Principal do Shell (REPL)</h2>
<p>O arquivo <code>index.c</code> contém a lógica central do shell, implementando o ciclo REPL (Read-Evaluate-Print/Execute-Loop). Este ciclo é o coração de qualquer shell interativo, onde o programa lê a entrada do usuário, a processa, executa o comando correspondente e repete o processo. Além do REPL, <code>index.c</code> gerencia a execução de comandos built-in e externos, bem como a divisão da linha de comando em argumentos.</p>
<h3 id="variaveis-globais">Variáveis Globais</h3>
<ul>
<li><code>int status = 0;</code>:<ul>
<li><strong>Propósito</strong>: Esta variável global armazena o status de saída do último comando executado. É um padrão comum em shells para que o status de saída possa ser consultado por comandos subsequentes ou scripts.</li>
</ul>
</li>
</ul>
<h3 id="funcoes-de-execucao-de-comandos">Funções de Execução de Comandos</h3>
<ul>
<li>
<p><code>void index_launch(char **args)</code>:</p>
<ul>
<li><strong>Propósito</strong>: Esta função é responsável por lançar a execução de comandos externos (não built-in).</li>
<li><strong>Funcionalidade</strong>: Ela utiliza o wrapper <code>Fork()</code> para criar um novo processo filho. Se for o processo filho (<code>INDEX_jr</code> é 0, conforme definido em <code>index.h</code>), ele chama <code>Execvp(args[0], args)</code> para substituir a imagem do processo filho pelo programa especificado em <code>args[0]</code> com seus respectivos argumentos. Se for o processo pai, ele chama <code>Wait(&amp;status)</code> para aguardar a conclusão do processo filho e coletar seu status de saída, que é armazenado na variável global <code>status</code>.</li>
<li><strong>Fluxo de Controle</strong>: Esta função é crucial para a capacidade do shell de executar programas externos, como <code>ls</code>, <code>grep</code>, etc.</li>
</ul>
</li>
<li>
<p><code>void index_exec(char **args)</code>:</p>
<ul>
<li><strong>Propósito</strong>: Esta é a função principal para a execução de comandos, atuando como um despachante para comandos built-in e externos.</li>
<li><strong>Funcionalidade</strong>: A função itera sobre a estrutura global <code>g_builtin</code> (definida em <code>index.c</code> e populada com os comandos built-in). Para cada entrada em <code>g_builtin</code>, ela compara o nome do comando built-in (<code>g_builtin[i].builtin_name</code>) com o primeiro argumento da linha de comando (<code>args[0]</code>) usando <code>strcmp</code>. Se uma correspondência for encontrada, a função associada ao built-in (<code>g_builtin[i].foo</code>) é chamada com os argumentos, e o valor de retorno (status de saída do built-in) é armazenado na variável global <code>status</code>. Após a execução do built-in, a função retorna.</li>
<li><strong>Comandos Built-in</strong>: A estrutura <code>g_builtin</code> é um array de <code>t_builtin</code> (definido em <code>index.h</code>), que mapeia nomes de comandos para ponteiros de função. Atualmente, inclui <code>env</code> e <code>exit</code>. A linha comentada <code>{.builtin_name ="echo", .foo=index_echo};</code> sugere que <code>echo</code> foi considerado ou pode ser adicionado no futuro.</li>
<li><strong>Execução de Comandos Externos</strong>: Se nenhum comando built-in corresponder ao <code>args[0]</code>, a função <code>index_launch(args)</code> é chamada para tentar executar o comando como um programa externo.</li>
</ul>
</li>
</ul>
<h3 id="funcoes-de-processamento-de-entrada">Funções de Processamento de Entrada</h3>
<ul>
<li>
<p><code>char **index_split_line(char *line)</code>:</p>
<ul>
<li><strong>Propósito</strong>: Esta função é responsável por tokenizar a linha de entrada do usuário em argumentos individuais.</li>
<li><strong>Funcionalidade</strong>: Ela utiliza a função <code>strtok</code> para dividir a string <code>line</code> em tokens, usando os delimitadores definidos pela macro <code>DEL</code> (espaço, tabulação, nova linha, etc.). A função aloca dinamicamente memória para armazenar os ponteiros para esses tokens. Se a capacidade do buffer for excedida, <code>Realloc</code> é usado para dobrar o tamanho do buffer, garantindo que todos os tokens possam ser armazenados. O array de tokens é terminado com <code>NULL</code>, o que é um padrão comum para arrays de strings em C.</li>
<li><strong>Gerenciamento de Memória</strong>: A memória para os tokens é alocada usando <code>Malloc</code> e <code>Realloc</code>, garantindo tratamento de erros para falhas de alocação.</li>
<li><strong>Retorno</strong>: Retorna um array de strings (<code>char **</code>) onde cada string é um argumento da linha de comando.</li>
</ul>
</li>
<li>
<p><code>char *index_read_line(void)</code>:</p>
<ul>
<li><strong>Propósito</strong>: Esta função lê uma linha de entrada do usuário do <code>stdin</code>.</li>
<li><strong>Funcionalidade</strong>: Ela exibe um prompt para o usuário, que inclui o diretório de trabalho atual (obtido via <code>Getcwd</code>) e um caractere de shell (<code>🐚</code>). Em seguida, usa <code>getline</code> para ler a linha completa, incluindo espaços, até que uma nova linha seja encontrada ou o final do arquivo seja atingido. <code>getline</code> aloca dinamicamente o buffer <code>buf</code> conforme necessário.</li>
<li><strong>Tratamento de Erros</strong>: Se <code>getline</code> falhar (retornar <code>-1</code>), a função libera o buffer alocado e verifica se o final do arquivo (<code>feof(stdin)</code>) foi atingido. Se sim, imprime <code>"[EOF]"</code>; caso contrário, imprime <code>"getline failed"</code>.</li>
<li><strong>Retorno</strong>: Retorna um ponteiro para a string lida ou <code>NULL</code> em caso de erro ou final de arquivo.</li>
</ul>
</li>
</ul>
<h3 id="funcao-principal-main">Função Principal (<code>main</code>)</h3>
<ul>
<li><code>int main()</code>:<ul>
<li><strong>Propósito</strong>: A função <code>main</code> é o ponto de entrada do programa shell e implementa o loop REPL.</li>
<li><strong>Fluxo de Execução</strong>: <ol>
<li><strong>Banner</strong>: Chama <code>printbanner()</code> para exibir uma mensagem de boas-vindas no início.</li>
<li><strong>Loop REPL</strong>: Entra em um loop infinito (<code>while((line = index_read_line()))</code>) que continua enquanto <code>index_read_line()</code> retornar uma linha válida (ou seja, não <code>NULL</code>).</li>
<li><strong>Leitura (Read)</strong>: Dentro do loop, <code>index_read_line()</code> é chamada para obter a entrada do usuário, exibindo o prompt e lendo a linha.</li>
<li><strong>Avaliação/Tokenização (Evaluate/Lexing/Parsing)</strong>: A linha lida é então passada para <code>index_split_line(line)</code> para ser tokenizada em argumentos.</li>
<li><strong>Execução (Execute)</strong>: Os argumentos tokenizados são passados para <code>index_exec(args)</code>, que decide se o comando é um built-in ou um programa externo e o executa.</li>
<li><strong>Liberação de Memória (Free)</strong>: Após a execução do comando, a memória alocada para a linha (<code>line</code>) e os argumentos (<code>args</code>) é liberada usando <code>free()</code>, prevenindo vazamentos de memória.</li>
<li><strong>Loop (Loop)</strong>: O ciclo se repete, solicitando uma nova entrada do usuário.</li>
</ol>
</li>
<li><strong>Saída</strong>: O loop termina quando <code>index_read_line()</code> retorna <code>NULL</code> (indicando EOF ou um erro fatal). O programa então retorna <code>EXIT_SUCCESS</code>.</li>
</ul>
</li>
</ul>
<h3 id="estrutura-g_builtin">Estrutura <code>g_builtin</code></h3>
<pre><code class="language-c">t_builtin g_builtin[] = {
 //   {.builtin_name =&quot;echo&quot;, .foo=index_echo};
    {.builtin_name =&quot;env&quot;, .foo=index_env};
    {.builtin_name =&quot;exit&quot;, .foo=index_exit},
    {.builtin_name =NULL}

};
</code></pre>
<ul>
<li><strong>Propósito</strong>: Esta é uma variável global que armazena a lista de comandos built-in que o shell suporta. É um array de estruturas <code>t_builtin</code>, onde cada elemento associa o nome de um comando built-in a um ponteiro para a função que o implementa.</li>
<li><strong>Extensibilidade</strong>: A estrutura é terminada com um elemento <code>NULL</code>, permitindo que o shell itere sobre ela para encontrar o comando built-in correto. Novas funções built-in podem ser adicionadas a este array para estender a funcionalidade do shell.</li>
</ul>
<p>Em resumo, <code>index.c</code> orquestra o fluxo de trabalho do shell, desde a interação com o usuário até a execução de comandos, garantindo que o shell funcione como um ambiente de linha de comando interativo e responsivo.</p>
<h2 id="conclusao">Conclusão</h2>
<p>O projeto de shell em C analisado demonstra uma implementação funcional de um interpretador de linha de comando básico. A arquitetura modular, com responsabilidades bem definidas para cada arquivo (<code>index.h</code>, <code>utils.c</code>, <code>builtin.c</code>, <code>index.c</code>), contribui para a clareza e manutenibilidade do código.</p>
<p>Os principais recursos implementados incluem:</p>
<ul>
<li><strong>Loop REPL</strong>: O shell lê comandos do usuário, os avalia e os executa, repetindo o ciclo.</li>
<li><strong>Execução de Comandos Externos</strong>: Capacidade de executar programas do sistema operacional através de <code>fork</code> e <code>execvp</code>.</li>
<li><strong>Comandos Built-in</strong>: Implementação de comandos internos como <code>exit</code> e <code>env</code>, que são executados diretamente pelo shell para maior eficiência.</li>
<li><strong>Tokenização de Linha de Comando</strong>: A entrada do usuário é dividida em tokens (comandos e argumentos) para processamento.</li>
<li><strong>Gerenciamento de Processos</strong>: Utilização de <code>fork</code>, <code>execvp</code> e <code>wait</code> para criar e gerenciar processos filhos.</li>
<li><strong>Gerenciamento de Memória</strong>: Uso de <code>malloc</code> e <code>realloc</code> com wrappers para tratamento de erros, garantindo alocação e realocação de memória seguras.</li>
<li><strong>Interface de Usuário Aprimorada</strong>: Uso de cores ANSI para prompts e mensagens, além de um banner de boas-vindas e uma animação de desligamento.</li>
</ul>
<p>O código demonstra boas práticas de programação em C, como o uso de wrappers para chamadas de sistema para centralizar o tratamento de erros e a liberação de memória alocada dinamicamente para evitar vazamentos.</p>
<h3 id="possiveis-melhorias-e-extensoes">Possíveis Melhorias e Extensões</h3>
<p>Embora funcional, o shell pode ser estendido com recursos adicionais para torná-lo mais robusto e completo, como:</p>
<ul>
<li><strong>Redirecionamento de Entrada/Saída</strong>: Implementar operadores como <code>&gt;</code>, <code>&lt;</code>, <code>&gt;&gt;</code> e <code>|</code> (pipes).</li>
<li><strong>Tratamento de Sinais</strong>: Melhorar o tratamento de sinais como <code>SIGINT</code> (Ctrl+C) e <code>SIGTSTP</code> (Ctrl+Z).</li>
<li><strong>Variáveis de Shell</strong>: Permitir a definição e o uso de variáveis de ambiente locais ao shell.</li>
<li><strong>Histórico de Comandos</strong>: Implementar um histórico de comandos navegável.</li>
<li><strong>Autocompletar</strong>: Adicionar funcionalidade de autocompletar para comandos e nomes de arquivos.</li>
<li><strong>Aliases</strong>: Permitir a criação de aliases para comandos.</li>
<li><strong>Jobs em Background</strong>: Suporte para executar comandos em segundo plano (usando <code>&amp;</code>).</li>
<li><strong>Scripting</strong>: Capacidade de executar scripts de shell.</li>
</ul>
<h2 id="limitacoes-conhecidas-da-implementacao">Limitações Conhecidas da Implementação</h2>
<p>Esta versão do mini-shell possui algumas limitações:</p>
<ul>
<li><strong>Comandos Built-in Fixos</strong>: A lista de comandos built-in (<code>env</code>, <code>exit</code>, <code>echo</code>) é fixa e não pode ser estendida dinamicamente em tempo de execução.</li>
<li><strong>Ausência de Variáveis de Ambiente do Shell</strong>: Não há suporte para variáveis de ambiente internas do shell (ex: <code>$PATH</code>, <code>$HOME</code>) que podem ser definidas e usadas dentro do shell.</li>
<li><strong>Sem Histórico de Comandos</strong>: Não há funcionalidade de histórico de comandos (setas para cima/baixo).</li>
<li><strong>Sem Autocompletar</strong>: Não há suporte para autocompletar nomes de arquivos ou comandos.</li>
<li><strong>Tratamento Básico de Erros</strong>: Embora <code>perror</code> seja usado para erros de chamadas de sistema, o tratamento de erros para comandos não encontrados é genérico ("Command not found") e não fornece detalhes específicos sobre o motivo da falha (ex: permissão negada, comando inexistente).</li>
<li><strong>Ausência de Comandos Complexos</strong>: Não há suporte para estruturas de controle de fluxo (if, for, while), execução em segundo plano (<code>&amp;</code>), ou encadeamento de comandos com <code>&amp;&amp;</code> ou <code>||</code>.</li>
<li><strong>Gerenciamento de Jobs</strong>: Não há suporte para gerenciamento de jobs (suspender, retomar processos).</li>
</ul></div>
            </div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script src="../js/bootstrap.bundle.min.js"></script>
        <script>
            var base_url = "..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../js/base.js"></script>
        <script src="../search/main.js"></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="searchModalLabel">Search</h4>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <p>From here you can search these documents. Enter your search terms below.</p>
                <form>
                    <div class="form-group">
                        <input type="search" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results" data-no-results-text="No results found"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
